{
  "language": "Solidity",
  "sources": {
    "@fhevm/solidity/config/ZamaConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {SepoliaZamaOracleAddress} from \"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\";\nimport {FHE} from \"../lib/FHE.sol\";\nimport {CoprocessorConfig} from \"../lib/Impl.sol\";\n\n/**\n * @title   ZamaConfig.\n * @notice  This library returns the FHEVM config for different networks\n *          with the contract addresses for (1) ACL, (2) CoprocessorAddress, (3) DecryptionOracleAddress, (4) KMSVerifier,\n *          which are deployed & maintained by Zama. It also returns the address of the decryption oracle.\n */\nlibrary ZamaConfig {\n    function getSepoliaProtocolId() internal pure returns (uint256) {\n        /// @note Zama Ethereum Sepolia protocol id is '10000 + Zama Ethereum protocol id'\n        return 10001;\n    }\n\n    function getSepoliaConfig() internal pure returns (CoprocessorConfig memory) {\n        return\n            CoprocessorConfig({\n                ACLAddress: 0x687820221192C5B662b25367F70076A37bc79b6c,\n                CoprocessorAddress: 0x848B0066793BcC60346Da1F49049357399B8D595,\n                DecryptionOracleAddress: SepoliaZamaOracleAddress,\n                KMSVerifierAddress: 0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC\n            });\n    }\n\n    function getEthereumProtocolId() internal pure returns (uint256) {\n        /// @note Zama Ethereum protocol id is '1'\n        return 1;\n    }\n\n    function getEthereumConfig() internal pure returns (CoprocessorConfig memory) {\n        /// @note The addresses below are placeholders and should be replaced with actual addresses\n        /// once deployed on the Ethereum mainnet.\n        return\n            CoprocessorConfig({\n                ACLAddress: address(0),\n                CoprocessorAddress: address(0),\n                DecryptionOracleAddress: address(0),\n                KMSVerifierAddress: address(0)\n            });\n    }\n}\n\n/**\n * @title   SepoliaConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Sepolia network (chainId = 11155111).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaConfig {\n    constructor() {\n        FHE.setCoprocessor(ZamaConfig.getSepoliaConfig());\n    }\n\n    function protocolId() public pure returns (uint256) {\n        return ZamaConfig.getSepoliaProtocolId();\n    }\n}\n\n/**\n * @title   EthereumConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumConfig {\n    constructor() {\n        FHE.setCoprocessor(ZamaConfig.getEthereumConfig());\n    }\n\n    function protocolId() public pure returns (uint256) {\n        return ZamaConfig.getEthereumProtocolId();\n    }\n}\n"
    },
    "@fhevm/solidity/lib/FHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./Impl.sol\";\nimport {FheType} from \"./FheType.sol\";\n\nimport \"encrypted-types/EncryptedTypes.sol\";\n\n/**\n * @title IKMSVerifier\n * @notice This interface contains the only function required from KMSVerifier.\n */\ninterface IKMSVerifier {\n    function verifyDecryptionEIP712KMSSignatures(\n        bytes32[] memory handlesList,\n        bytes memory decryptedResult,\n        bytes memory decryptionProof\n    ) external returns (bool);\n}\n\n/**\n * @title IDecryptionOracle\n * @notice This interface contains the only function required from DecryptionOracle.\n */\ninterface IDecryptionOracle {\n    function requestDecryption(\n        uint256 requestID,\n        bytes32[] calldata ctsHandles,\n        bytes4 callbackSelector\n    ) external payable;\n}\n\n/**\n * @title   FHE\n * @notice  This library is the interaction point for all smart contract developers\n *          that interact with the FHEVM protocol.\n */\nlibrary FHE {\n    /// @notice Returned if some handles were already saved for corresponding ID.\n    error HandlesAlreadySavedForRequestID();\n\n    /// @notice Returned if there was not handle found for the requested ID.\n    error NoHandleFoundForRequestID();\n\n    /// @notice Returned if the returned KMS signatures are not valid.\n    error InvalidKMSSignatures();\n\n    /// @notice This event is emitted when requested decryption has been fulfilled.\n    event DecryptionFulfilled(uint256 indexed requestID);\n\n    /**\n     * @notice                  Sets the coprocessor addresses.\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\n     */\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\n        Impl.setCoprocessor(coprocessorConfig);\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return euint64.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return euint128.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return eaddress.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return euint256.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\n     */\n    function and(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\n     */\n    function or(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\n     */\n    function xor(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\n     */\n    function eq(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\n     */\n    function ne(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\n     */\n    function add(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\n     */\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\n     */\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\n     */\n    function and(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\n     */\n    function or(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\n     */\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\n     */\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\n     */\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\n     */\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\n     */\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\n     */\n    function le(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\n     */\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\n     */\n    function min(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\n     */\n    function max(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\n     */\n    function add(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\n     */\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\n     */\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\n     */\n    function and(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\n     */\n    function or(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\n     */\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\n     */\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\n     */\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\n     */\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\n     */\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\n     */\n    function le(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\n     */\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\n     */\n    function min(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\n     */\n    function max(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\n     */\n    function add(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\n     */\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\n     */\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\n     */\n    function and(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\n     */\n    function or(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\n     */\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\n     */\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\n     */\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\n     */\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\n     */\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\n     */\n    function le(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\n     */\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\n     */\n    function min(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\n     */\n    function max(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\n     */\n    function add(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\n     */\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\n     */\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\n     */\n    function and(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\n     */\n    function or(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\n     */\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\n     */\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\n     */\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\n     */\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\n     */\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\n     */\n    function le(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\n     */\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\n     */\n    function min(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\n     */\n    function max(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\n     */\n    function add(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\n     */\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\n     */\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\n     */\n    function and(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\n     */\n    function or(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\n     */\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\n     */\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\n     */\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\n     */\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\n     */\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\n     */\n    function le(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\n     */\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\n     */\n    function min(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\n     */\n    function max(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\n     */\n    function and(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\n     */\n    function or(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\n     */\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\n     */\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\n     */\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\n     */\n    function add(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\n     */\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\n     */\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\n     */\n    function and(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\n     */\n    function or(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\n     */\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\n     */\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\n     */\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\n     */\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\n     */\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\n     */\n    function le(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\n     */\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\n     */\n    function min(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\n     */\n    function max(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\n     */\n    function add(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\n     */\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\n     */\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\n     */\n    function and(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\n     */\n    function or(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\n     */\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\n     */\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\n     */\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\n     */\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\n     */\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\n     */\n    function le(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\n     */\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\n     */\n    function min(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\n     */\n    function max(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\n     */\n    function add(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\n     */\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\n     */\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\n     */\n    function and(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\n     */\n    function or(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\n     */\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\n     */\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\n     */\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\n     */\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\n     */\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\n     */\n    function le(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\n     */\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\n     */\n    function min(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\n     */\n    function max(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\n     */\n    function add(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\n     */\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\n     */\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\n     */\n    function and(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\n     */\n    function or(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\n     */\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\n     */\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\n     */\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\n     */\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\n     */\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\n     */\n    function le(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\n     */\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\n     */\n    function min(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\n     */\n    function max(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\n     */\n    function add(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\n     */\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\n     */\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\n     */\n    function and(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\n     */\n    function or(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\n     */\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\n     */\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\n     */\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\n     */\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\n     */\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\n     */\n    function le(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\n     */\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\n     */\n    function min(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\n     */\n    function max(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\n     */\n    function and(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\n     */\n    function or(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\n     */\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\n     */\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\n     */\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\n     */\n    function add(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\n     */\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\n     */\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\n     */\n    function and(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\n     */\n    function or(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\n     */\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\n     */\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\n     */\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\n     */\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\n     */\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\n     */\n    function le(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\n     */\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\n     */\n    function min(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\n     */\n    function max(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\n     */\n    function add(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\n     */\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\n     */\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\n     */\n    function and(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\n     */\n    function or(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\n     */\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\n     */\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\n     */\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\n     */\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\n     */\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\n     */\n    function le(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\n     */\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\n     */\n    function min(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\n     */\n    function max(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\n     */\n    function add(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\n     */\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\n     */\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\n     */\n    function and(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\n     */\n    function or(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\n     */\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\n     */\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\n     */\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\n     */\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\n     */\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\n     */\n    function le(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\n     */\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\n     */\n    function min(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\n     */\n    function max(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\n     */\n    function add(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\n     */\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\n     */\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\n     */\n    function and(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\n     */\n    function or(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\n     */\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\n     */\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\n     */\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\n     */\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\n     */\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\n     */\n    function le(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\n     */\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\n     */\n    function min(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\n     */\n    function max(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\n     */\n    function add(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\n     */\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\n     */\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\n     */\n    function and(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\n     */\n    function or(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\n     */\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\n     */\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\n     */\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\n     */\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\n     */\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\n     */\n    function le(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\n     */\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\n     */\n    function min(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\n     */\n    function max(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\n     */\n    function and(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\n     */\n    function or(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\n     */\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\n     */\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\n     */\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\n     */\n    function add(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\n     */\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\n     */\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\n     */\n    function and(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\n     */\n    function or(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\n     */\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\n     */\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\n     */\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\n     */\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\n     */\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\n     */\n    function le(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\n     */\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\n     */\n    function min(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\n     */\n    function max(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\n     */\n    function add(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\n     */\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\n     */\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\n     */\n    function and(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\n     */\n    function or(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\n     */\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\n     */\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\n     */\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\n     */\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\n     */\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\n     */\n    function le(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\n     */\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\n     */\n    function min(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\n     */\n    function max(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\n     */\n    function add(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\n     */\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\n     */\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\n     */\n    function and(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\n     */\n    function or(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\n     */\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\n     */\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\n     */\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\n     */\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\n     */\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\n     */\n    function le(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\n     */\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\n     */\n    function min(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\n     */\n    function max(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\n     */\n    function add(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\n     */\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\n     */\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\n     */\n    function and(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\n     */\n    function or(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\n     */\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\n     */\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\n     */\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\n     */\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\n     */\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\n     */\n    function le(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\n     */\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\n     */\n    function min(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\n     */\n    function max(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\n     */\n    function add(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\n     */\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\n     */\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\n     */\n    function and(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\n     */\n    function or(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\n     */\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\n     */\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\n     */\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\n     */\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\n     */\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\n     */\n    function le(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\n     */\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\n     */\n    function min(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\n     */\n    function max(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\n     */\n    function and(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\n     */\n    function or(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\n     */\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\n     */\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\n     */\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\n     */\n    function add(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\n     */\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\n     */\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\n     */\n    function and(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\n     */\n    function or(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\n     */\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\n     */\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\n     */\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\n     */\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\n     */\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\n     */\n    function le(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\n     */\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\n     */\n    function min(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\n     */\n    function max(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\n     */\n    function add(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\n     */\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\n     */\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\n     */\n    function and(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\n     */\n    function or(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\n     */\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\n     */\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\n     */\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\n     */\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\n     */\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\n     */\n    function le(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\n     */\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\n     */\n    function min(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\n     */\n    function max(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\n     */\n    function add(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\n     */\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\n     */\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\n     */\n    function and(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\n     */\n    function or(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\n     */\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\n     */\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\n     */\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\n     */\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\n     */\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\n     */\n    function le(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\n     */\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\n     */\n    function min(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\n     */\n    function max(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\n     */\n    function add(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\n     */\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\n     */\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\n     */\n    function and(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\n     */\n    function or(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\n     */\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\n     */\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\n     */\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\n     */\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\n     */\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\n     */\n    function le(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\n     */\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\n     */\n    function min(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\n     */\n    function max(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\n     */\n    function add(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\n     */\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\n     */\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\n     */\n    function and(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\n     */\n    function or(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\n     */\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\n     */\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\n     */\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\n     */\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\n     */\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\n     */\n    function le(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\n     */\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\n     */\n    function min(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\n     */\n    function max(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\n     */\n    function and(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\n     */\n    function or(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\n     */\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\n     */\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\n     */\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\n     */\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\n     */\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\n     */\n    function and(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\n     */\n    function or(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\n     */\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\n     */\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\n     */\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\n     */\n    function and(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\n     */\n    function or(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\n     */\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\n     */\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\n     */\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\n     */\n    function and(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\n     */\n    function or(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\n     */\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\n     */\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\n     */\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\n     */\n    function and(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\n     */\n    function or(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\n     */\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\n     */\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\n     */\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\n     */\n    function and(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\n     */\n    function or(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\n     */\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\n     */\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\n     */\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\n     */\n    function and(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\n     */\n    function or(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\n     */\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\n     */\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\n     */\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\n     */\n    function and(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\n     */\n    function and(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\n     */\n    function or(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\n     */\n    function or(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\n     */\n    function xor(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\n     */\n    function xor(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\n     */\n    function eq(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\n     */\n    function eq(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\n     */\n    function ne(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\n     */\n    function ne(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\n     */\n    function add(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\n     */\n    function add(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\n     */\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\n     */\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\n     */\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\n     */\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\n     */\n    function div(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\n     */\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\n     */\n    function and(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\n     */\n    function and(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\n     */\n    function or(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\n     */\n    function or(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\n     */\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\n     */\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\n     */\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\n     */\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\n     */\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\n     */\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\n     */\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\n     */\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\n     */\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\n     */\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\n     */\n    function le(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\n     */\n    function le(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\n     */\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\n     */\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\n     */\n    function min(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\n     */\n    function min(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\n     */\n    function max(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\n     */\n    function max(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\n     */\n    function add(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\n     */\n    function add(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\n     */\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\n     */\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\n     */\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\n     */\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\n     */\n    function div(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\n     */\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\n     */\n    function and(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\n     */\n    function and(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\n     */\n    function or(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\n     */\n    function or(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\n     */\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\n     */\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\n     */\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\n     */\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\n     */\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\n     */\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\n     */\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\n     */\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\n     */\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\n     */\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\n     */\n    function le(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\n     */\n    function le(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\n     */\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\n     */\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\n     */\n    function min(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\n     */\n    function min(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\n     */\n    function max(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\n     */\n    function max(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\n     */\n    function add(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\n     */\n    function add(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\n     */\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\n     */\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\n     */\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\n     */\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\n     */\n    function div(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\n     */\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\n     */\n    function and(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\n     */\n    function and(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\n     */\n    function or(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\n     */\n    function or(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\n     */\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\n     */\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\n     */\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\n     */\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\n     */\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\n     */\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\n     */\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\n     */\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\n     */\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\n     */\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\n     */\n    function le(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\n     */\n    function le(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\n     */\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\n     */\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\n     */\n    function min(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\n     */\n    function min(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\n     */\n    function max(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\n     */\n    function max(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\n     */\n    function add(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\n     */\n    function add(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\n     */\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\n     */\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\n        euint64 aEnc = asEuint64(a);\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\n     */\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\n     */\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\n     */\n    function div(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\n     */\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\n     */\n    function and(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\n     */\n    function and(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\n     */\n    function or(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\n     */\n    function or(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\n     */\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\n     */\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\n     */\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\n     */\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\n     */\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\n     */\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\n     */\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\n     */\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\n     */\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\n     */\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\n     */\n    function le(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\n     */\n    function le(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\n     */\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\n     */\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\n     */\n    function min(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\n     */\n    function min(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\n     */\n    function max(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\n     */\n    function max(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\n     */\n    function add(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\n     */\n    function add(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\n     */\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\n     */\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\n        euint128 aEnc = asEuint128(a);\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\n     */\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\n     */\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\n     */\n    function div(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\n     */\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\n     */\n    function and(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\n     */\n    function and(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\n     */\n    function or(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\n     */\n    function or(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\n     */\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\n     */\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\n     */\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\n     */\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\n     */\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\n     */\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\n     */\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\n     */\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\n     */\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\n     */\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\n     */\n    function le(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\n     */\n    function le(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\n     */\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\n     */\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\n     */\n    function min(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\n     */\n    function min(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\n     */\n    function max(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\n     */\n    function max(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\n     */\n    function eq(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\n    }\n\n    /**\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\n     */\n    function eq(address a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\n    }\n\n    /**\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\n     */\n    function ne(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\n    }\n\n    /**\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\n     */\n    function ne(address a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\n     */\n    function and(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\n     */\n    function and(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\n     */\n    function or(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\n     */\n    function or(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\n     */\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\n     */\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\n     */\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\n     */\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\n     */\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\n     */\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\n     */\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\n     */\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\n     */\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\n     */\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\n     */\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\n     */\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\n     */\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\n     */\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\n     */\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\n     */\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\n     */\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\n     */\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\n     */\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\n     */\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\n     */\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\n     */\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\n     */\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\n     */\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\n     */\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\n     */\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\n     */\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\n     */\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\n     */\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\n     */\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\n     */\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\n     */\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\n     */\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\n     */\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\n     */\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\n     */\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\n     */\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\n     */\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\n     */\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\n     */\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\n     */\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\n     */\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\n     */\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\n     */\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\n     */\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\n     */\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\n     */\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\n     */\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\n     */\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\n     */\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\n     */\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\n     */\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\n     */\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\n     */\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\n    }\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\n     */\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\n     */\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\n     */\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\n     */\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\n     */\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint8'.\n     */\n    function asEuint8(ebool b) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\n     */\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\n     */\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\n     */\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\n     */\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\n     */\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\n     */\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint16'.\n     */\n    function asEuint16(ebool b) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\n     */\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\n     */\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\n     */\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\n     */\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\n     */\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\n     */\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint32'.\n     */\n    function asEuint32(ebool b) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\n     */\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\n     */\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\n     */\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\n     */\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\n     */\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\n     */\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint64'.\n     */\n    function asEuint64(ebool b) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\n     */\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\n     */\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\n     */\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\n     */\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\n     */\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\n     */\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint128'.\n     */\n    function asEuint128(ebool b) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\n     */\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\n     */\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\n     */\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\n     */\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\n     */\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\n     */\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint256'.\n     */\n    function asEuint256(ebool b) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\n     */\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Evaluates not(ebool value) and returns the result.\n     */\n    function not(ebool value) internal returns (ebool) {\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint8 value) and returns the result.\n     */\n    function neg(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint8 value) and returns the result.\n     */\n    function not(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint16 value) and returns the result.\n     */\n    function neg(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint16 value) and returns the result.\n     */\n    function not(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint32 value) and returns the result.\n     */\n    function neg(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint32 value) and returns the result.\n     */\n    function not(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint64 value) and returns the result.\n     */\n    function neg(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint64 value) and returns the result.\n     */\n    function not(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint128 value) and returns the result.\n     */\n    function neg(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint128 value) and returns the result.\n     */\n    function not(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint256 value) and returns the result.\n     */\n    function neg(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint256 value) and returns the result.\n     */\n    function not(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\n     */\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\n    }\n\n    /**\n     * @dev Converts a plaintext boolean to an encrypted boolean.\n     */\n    function asEbool(bool value) internal returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\n     */\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\n     */\n    function asEuint8(uint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\n     */\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\n     */\n    function asEuint16(uint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\n     */\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\n     */\n    function asEuint32(uint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\n     */\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\n     */\n    function asEuint64(uint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\n     */\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\n     */\n    function asEuint128(uint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\n     */\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\n     */\n    function asEaddress(address value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\n     */\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\n     */\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEbool() internal returns (ebool) {\n        return ebool.wrap(Impl.rand(FheType.Bool));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint8() internal returns (euint8) {\n        return euint8.wrap(Impl.rand(FheType.Uint8));\n    }\n\n    /**\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint16() internal returns (euint16) {\n        return euint16.wrap(Impl.rand(FheType.Uint16));\n    }\n\n    /**\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint32() internal returns (euint32) {\n        return euint32.wrap(Impl.rand(FheType.Uint32));\n    }\n\n    /**\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint64() internal returns (euint64) {\n        return euint64.wrap(Impl.rand(FheType.Uint64));\n    }\n\n    /**\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint128() internal returns (euint128) {\n        return euint128.wrap(Impl.rand(FheType.Uint128));\n    }\n\n    /**\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint256() internal returns (euint256) {\n        return euint256.wrap(Impl.rand(FheType.Uint256));\n    }\n\n    /**\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\n    }\n\n    /**\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\n     *      (input proofs).\n     *      This could be useful for integration with Account Abstraction when bundling several\n     *      UserOps calling the FHEVMExecutor.\n     */\n    function cleanTransientStorage() internal {\n        Impl.cleanTransientStorageACL();\n        Impl.cleanTransientStorageInputVerifier();\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(ebool value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(ebool value) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(ebool value, address account) internal returns (ebool) {\n        Impl.allow(ebool.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(ebool value) internal returns (ebool) {\n        Impl.allow(ebool.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(ebool value, address account) internal returns (ebool) {\n        Impl.allowTransient(ebool.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint8 value, address account) internal returns (euint8) {\n        Impl.allow(euint8.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint8 value) internal returns (euint8) {\n        Impl.allow(euint8.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\n        Impl.allowTransient(euint8.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint16 value, address account) internal returns (euint16) {\n        Impl.allow(euint16.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint16 value) internal returns (euint16) {\n        Impl.allow(euint16.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\n        Impl.allowTransient(euint16.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint32 value, address account) internal returns (euint32) {\n        Impl.allow(euint32.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint32 value) internal returns (euint32) {\n        Impl.allow(euint32.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\n        Impl.allowTransient(euint32.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint64 value, address account) internal returns (euint64) {\n        Impl.allow(euint64.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint64 value) internal returns (euint64) {\n        Impl.allow(euint64.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\n        Impl.allowTransient(euint64.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint128 value, address account) internal returns (euint128) {\n        Impl.allow(euint128.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint128 value) internal returns (euint128) {\n        Impl.allow(euint128.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\n        Impl.allowTransient(euint128.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(eaddress value, address account) internal returns (eaddress) {\n        Impl.allow(eaddress.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(eaddress value) internal returns (eaddress) {\n        Impl.allow(eaddress.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\n        Impl.allowTransient(eaddress.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint256 value, address account) internal returns (euint256) {\n        Impl.allow(euint256.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint256 value) internal returns (euint256) {\n        Impl.allow(euint256.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\n        Impl.allowTransient(euint256.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\n    }\n\n    /**\n     * @dev Recovers the stored array of handles corresponding to requestID.\n     */\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        if ($.requestedHandles[requestID].length == 0) {\n            revert NoHandleFoundForRequestID();\n        }\n        return $.requestedHandles[requestID];\n    }\n\n    /**\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\n     */\n    function requestDecryption(\n        bytes32[] memory ctsHandles,\n        bytes4 callbackSelector\n    ) internal returns (uint256 requestID) {\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\n    }\n\n    /**\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\n     */\n    function requestDecryption(\n        bytes32[] memory ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue\n    ) internal returns (uint256 requestID) {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        requestID = $.counterRequest;\n        CoprocessorConfig storage $$ = Impl.getCoprocessorConfig();\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\n        IDecryptionOracle($$.DecryptionOracleAddress).requestDecryption{value: msgValue}(\n            requestID,\n            ctsHandles,\n            callbackSelector\n        );\n        saveRequestedHandles(requestID, ctsHandles);\n        $.counterRequest++;\n    }\n\n    /**\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\n     * @dev     otherwise fake decryption results could be submitted.\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\n     */\n    function checkSignatures(uint256 requestID, bytes memory cleartexts, bytes memory decryptionProof) internal {\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\n        bool isVerified = verifySignatures(handlesList, cleartexts, decryptionProof);\n        if (!isVerified) {\n            revert InvalidKMSSignatures();\n        }\n        emit DecryptionFulfilled(requestID);\n    }\n\n    /**\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\n     */\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        if ($.requestedHandles[requestID].length != 0) {\n            revert HandlesAlreadySavedForRequestID();\n        }\n        $.requestedHandles[requestID] = handlesList;\n    }\n\n    /**\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\n     * @dev The callback function has the following signature:\n     * - requestID (static uint256)\n     * - cleartexts (dynamic bytes)\n     * - decryptionProof (dynamic bytes)\n     *\n     * This means that the calldata is encoded in the following way:\n     * - 4 bytes: selector\n     * - 32 bytes: requestID\n     * - 32 bytes: offset of the cleartexts\n     * - 32 bytes: offset of the decryptionProof\n     * - 32 bytes: length of the cleartexts (total number of bytes)\n     * - n*32 bytes: the \"n\" cleartext values, with \"n\" the number of handles\n     * - 32 bytes: length of the decryptionProof (total number of bytes)\n     * - ... the data of the decryptionProof (signatures, extra data)\n     */\n    function verifySignatures(\n        bytes32[] memory handlesList,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) private returns (bool) {\n        // Compute the signature offset\n        // This offset is computed by considering the format encoded by the KMS when creating the\n        // \"decryptedResult\" bytes array (see comment below), which is the following:\n        // - requestID: 32 bytes\n        // - all \"n\" decrypted values (which is \"cleartexts\" itself): n*32 bytes (\"cleartexts.length\" bytes)\n        // - offset of the signatures: 32 bytes\n        // - the rest of signature values (lengths, offsets, values)\n        // This means the expected offset to concatenate to the \"decryptedResult\" bytes array has\n        // the following value: 32 + n*32 + 32\n        // See https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types for more details.\n        // The signature offset will most likely be removed in the future,\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\n        uint256 signaturesOffset = 32 + cleartexts.length + 32;\n\n        // Built the \"decryptedResult\" bytes array\n        // Currently, the \"decryptedResult\" is encoded (by the KMS) in the following format:\n        // - n*32 bytes: the \"n\" decrypted values, \"cleartexts\" itself\n        // - 32 bytes: offset of the signatures, as explained above\n        // This is equivalent to concatenating the cleartexts and the signatures offset, which can\n        // be done using abi.encoded in a gas efficient way.\n        // The signature offset will most likely be removed in the future,\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\n        // Here we can use \"encodePacked\" instead of \"abi.encode\" to save gas, as the cleartexts\n        // and the signaturesOffset are already 32 bytes aligned (ie, no padding needed).\n        bytes memory decryptedResult = abi.encodePacked(cleartexts, signaturesOffset);\n\n        CoprocessorConfig storage $ = Impl.getCoprocessorConfig();\n        return\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\n                handlesList,\n                decryptedResult,\n                decryptionProof\n            );\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\n        ct = ebool.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\n        ct = euint8.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\n        ct = euint16.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\n        ct = euint32.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\n        ct = euint64.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\n        ct = euint128.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\n        ct = eaddress.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\n        ct = euint256.unwrap(value);\n    }\n}\n"
    },
    "@fhevm/solidity/lib/FheType.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nenum FheType {\n    Bool,\n    Uint4,\n    Uint8,\n    Uint16,\n    Uint32,\n    Uint64,\n    Uint128,\n    Uint160,\n    Uint256,\n    Uint512,\n    Uint1024,\n    Uint2048,\n    Uint2,\n    Uint6,\n    Uint10,\n    Uint12,\n    Uint14,\n    Int2,\n    Int4,\n    Int6,\n    Int8,\n    Int10,\n    Int12,\n    Int14,\n    Int16,\n    Int32,\n    Int64,\n    Int128,\n    Int160,\n    Int256,\n    AsciiString,\n    Int512,\n    Int1024,\n    Int2048,\n    Uint24,\n    Uint40,\n    Uint48,\n    Uint56,\n    Uint72,\n    Uint80,\n    Uint88,\n    Uint96,\n    Uint104,\n    Uint112,\n    Uint120,\n    Uint136,\n    Uint144,\n    Uint152,\n    Uint168,\n    Uint176,\n    Uint184,\n    Uint192,\n    Uint200,\n    Uint208,\n    Uint216,\n    Uint224,\n    Uint232,\n    Uint240,\n    Uint248,\n    Int24,\n    Int40,\n    Int48,\n    Int56,\n    Int72,\n    Int80,\n    Int88,\n    Int96,\n    Int104,\n    Int112,\n    Int120,\n    Int136,\n    Int144,\n    Int152,\n    Int168,\n    Int176,\n    Int184,\n    Int192,\n    Int200,\n    Int208,\n    Int216,\n    Int224,\n    Int232,\n    Int240,\n    Int248\n}\n"
    },
    "@fhevm/solidity/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FheType} from \"./FheType.sol\";\n\n/**\n * @title   CoprocessorConfig\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\n */\nstruct CoprocessorConfig {\n    address ACLAddress;\n    address CoprocessorAddress;\n    address DecryptionOracleAddress;\n    address KMSVerifierAddress;\n}\n\n/**\n * @title   DecryptionRequests\n * @notice  This struct contains the internal counter for requestIDs generated by the dapp,\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\n */\nstruct DecryptionRequests {\n    uint256 counterRequest;\n    mapping(uint256 => bytes32[]) requestedHandles;\n}\n\n/**\n * @title   IFHEVMExecutor\n * @notice  This interface contains all functions to conduct FHE operations.\n */\ninterface IFHEVMExecutor {\n    /**\n     * @notice              Computes fheAdd operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheSub operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMul operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheDiv operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRem operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitAnd operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitOr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitXor operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheShl operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheShr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRotl operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRotr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheEq operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheGe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheGt operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheLe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheLt operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMin operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMax operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNeg operation.\n     * @param ct            Ct\n     * @return result       Result.\n     */\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNot operation.\n     * @param ct            Ct\n     * @return result       Result.\n     */\n    function fheNot(bytes32 ct) external returns (bytes32 result);\n    /**\n     * @notice                Verifies the ciphertext.\n     * @param inputHandle     Input handle.\n     * @param callerAddress   Address of the caller.\n     * @param inputProof      Input proof.\n     * @param inputType       Input type.\n     * @return result         Result.\n     */\n    function verifyCiphertext(\n        bytes32 inputHandle,\n        address callerAddress,\n        bytes memory inputProof,\n        FheType inputType\n    ) external returns (bytes32 result);\n\n    /**\n     * @notice          Performs the casting to a target type.\n     * @param ct        Value to cast.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\n\n    /**\n     * @notice          Does trivial encryption.\n     * @param ct        Value to encrypt.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHEIfThenElse operation.\n     * @param control       Control value.\n     * @param ifTrue        If true.\n     * @param ifFalse       If false.\n     * @return result       Result.\n     */\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHERand operation.\n     * @param randType      Type for the random result.\n     * @return result       Result.\n     */\n    function fheRand(FheType randType) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHERandBounded operation.\n     * @param upperBound    Upper bound value.\n     * @param randType      Type for the random result.\n     * @return result       Result.\n     */\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\n\n    /**\n     * @notice                      Returns the address of the InputVerifier contract used by the coprocessor.\n     * @return inputVerifierAddress Address of the InputVerifier.\n     */\n    function getInputVerifierAddress() external view returns (address);\n}\n\n/**\n * @title   IACL.\n * @notice  This interface contains all functions that are used to conduct operations\n *          with the ACL contract.\n */\ninterface IACL {\n    /**\n     * @notice              Allows the use of handle by address account for this transaction.\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\n     *                      If not, allowTransient() reverts.\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\n     * @param ciphertext    Ciphertext.\n     * @param account       Address of the account.\n     */\n    function allowTransient(bytes32 ciphertext, address account) external;\n\n    /**\n     * @notice              Allows the use of handle for the address account.\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allow(bytes32 handle, address account) external;\n\n    /**\n     * @dev This function removes the transient allowances, which could be useful for integration with\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorage() external;\n\n    /**\n     * @notice              Returns whether the account is allowed to use the handle, either due to\n     *                      allowTransient() or allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     * @return isAllowed    Whether the account can access the handle.\n     */\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\n\n    /**\n     * @notice              Allows a list of handles to be decrypted.\n     * @param handlesList   List of handles.\n     */\n    function allowForDecryption(bytes32[] memory handlesList) external;\n\n    /**\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\n     * @param handle            Handle.\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\n     */\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\n}\n\n/**\n * @title IInputVerifier\n * @notice This interface contains the only function required from InputVerifier.\n */\ninterface IInputVerifier {\n    /**\n     * @dev This function removes the transient allowances, which could be useful for integration with\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorage() external;\n}\n\n/**\n * @title   Impl\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\n */\nlibrary Impl {\n    /// keccak256(abi.encode(uint256(keccak256(\"confidential.storage.config\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CoprocessorConfigLocation =\n        0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700;\n\n    /// keccak256(abi.encode(uint256(keccak256(\"confidential.storage.decryptionRequests\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant DecryptionRequestsStorageLocation =\n        0x878245876662ba28a480c5ea71726db859fb50222b0a3d7cbbc21cfa336faf00;\n\n    /**\n     * @dev Returns the Coprocessor config.\n     */\n    function getCoprocessorConfig() internal pure returns (CoprocessorConfig storage $) {\n        assembly {\n            $.slot := CoprocessorConfigLocation\n        }\n    }\n\n    /**\n     * @dev Returns the DecryptionRequests storage struct.\n     */\n    function getDecryptionRequests() internal pure returns (DecryptionRequests storage $) {\n        assembly {\n            $.slot := DecryptionRequestsStorageLocation\n        }\n    }\n\n    /**\n     * @notice                  Sets the coprocessor addresses.\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\n     */\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        $.ACLAddress = coprocessorConfig.ACLAddress;\n        $.CoprocessorAddress = coprocessorConfig.CoprocessorAddress;\n        $.DecryptionOracleAddress = coprocessorConfig.DecryptionOracleAddress;\n        $.KMSVerifierAddress = coprocessorConfig.KMSVerifierAddress;\n    }\n\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\n        bytes1 scalarByte = 0x01;\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\n        bytes1 scalarByte = 0x01;\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotl(lhs, rhs, scalarByte);\n    }\n\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotr(lhs, rhs, scalarByte);\n    }\n\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(bytes32 ct) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNeg(ct);\n    }\n\n    function not(bytes32 ct) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNot(ct);\n    }\n\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    /**\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\n     * @param inputHandle   Input handle.\n     * @param inputProof    Input proof.\n     * @param toType        Input type.\n     * @return result       Result.\n     */\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\n    }\n\n    /**\n     * @notice            Performs the casting to a target type.\n     * @param ciphertext  Ciphertext to cast.\n     * @param toType      Target type.\n     * @return result     Result value of the target type.\n     */\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).cast(ciphertext, toType);\n    }\n\n    /**\n     * @notice          Does trivial encryption.\n     * @param value     Value to encrypt.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).trivialEncrypt(value, toType);\n    }\n\n    function rand(FheType randType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRand(randType);\n    }\n\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRandBounded(upperBound, randType);\n    }\n\n    /**\n     * @notice              Allows the use of handle by address account for this transaction.\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\n     *                      If not, allowTransient() reverts.\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allowTransient(bytes32 handle, address account) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).allowTransient(handle, account);\n    }\n\n    /**\n     * @notice              Allows the use of handle for the address account.\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allow(bytes32 handle, address account) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).allow(handle, account);\n    }\n\n    /**\n     * @notice              Allows the handle to be publicly decryptable.\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\n     *                      If not, makePubliclyDecryptable() reverts.\n     * @param handle        Handle.\n     */\n    function makePubliclyDecryptable(bytes32 handle) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        bytes32[] memory handleArray = new bytes32[](1);\n        handleArray[0] = handle;\n        IACL($.ACLAddress).allowForDecryption(handleArray);\n    }\n\n    /**\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorageACL() internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).cleanTransientStorage();\n    }\n\n    /**\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorageInputVerifier() internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        address inputVerifierAddress = IFHEVMExecutor($.CoprocessorAddress).getInputVerifierAddress();\n        IInputVerifier(inputVerifierAddress).cleanTransientStorage();\n    }\n\n    /**\n     * @notice              Returns whether the account is allowed to use the handle, either due to\n     *                      allowTransient() or allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     * @return isAllowed    Whether the account can access the handle.\n     */\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        return IACL($.ACLAddress).isAllowed(handle, account);\n    }\n\n    /**\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\n     * @param handle        Handle.\n     * @return isAllowed    Whether the handle can be publicly decrypted.\n     */\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\naddress constant SepoliaZamaOracleAddress = 0xa02Cda4Ca3a71D7C46997716F4283aa851C28812;\n"
    },
    "contracts/ConfidentialFundraising.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport \"./interface/IDecryptionCallbacks.sol\";\nimport \"./interface/IFundraisingEvents.sol\";\nimport \"./interface/IFundraisingErrors.sol\";\nimport \"./storage/FundraisingStorage.sol\";\nimport \"./interface/impl/DecryptionCallback.sol\";\nimport \"./ShareVault.sol\";\nimport \"./core/CampaignToken.sol\";\nimport \"./ShareVault.sol\";\n\n/**\n * @title ConfidentialFundraising\n * @notice A privacy-preserving crowdfunding platform using fully homomorphic encryption (FHE)\n * @dev This contract enables confidential fundraising campaigns where contribution amounts remain encrypted\n * on-chain. It leverages FHEVM to perform operations on encrypted data without revealing individual\n * contribution amounts. Only authorized parties can decrypt specific values after requesting decryption.\n *\n * Key Features:\n * - Encrypted contribution tracking using FHE\n * - Decentralized fund management through ShareVault\n * - Automatic token distribution for successful campaigns\n * - Refund mechanism for failed campaigns\n * - Time-based campaign deadlines\n *\n * @custom:security-contact security@example.com\n *\n * Note: Contribution amounts and targets are stored in wei, not ether units\n */\ncontract ConfidentialFundraising is\n    SepoliaConfig,\n    IFundraisingEvents,\n    IFundraisingErrors,\n    FundraisingStorage,\n    DecryptionCallbacks\n{\n    using FHE for euint16;\n    using FHE for euint64;\n    using FHE for ebool;\n\n    ShareVault public immutable shareVault;\n\n    modifier onlyCampaignOwner(uint16 campaignId) {\n        if (msg.sender != campaigns[campaignId].owner) {\n            revert OnlyOwner();\n        }\n        _;\n    }\n\n    constructor(address _shareVault) {\n        shareVault = ShareVault(_shareVault);\n    }\n\n    /**\n     * @notice Creates a new fundraising campaign\n     * @dev Initializes an encrypted total raised counter and sets campaign parameters.\n     * The campaign owner can later finalize it after the deadline to distribute tokens or refunds.\n     * @param title The campaign title (must not be empty)\n     * @param description The campaign description\n     * @param target The funding target amount in wei (must be greater than 0)\n     * @param duration The campaign duration in seconds (must be greater than 0)\n     * @return The newly created campaign ID\n     * @custom:emits CampaignCreated\n     */\n    function createCampaign(\n        string calldata title,\n        string calldata description,\n        uint64 target,\n        uint256 duration\n    ) external returns (uint256) {\n        if (target == 0) {\n            revert InvalidTarget();\n        }\n        if (duration == 0) {\n            revert InvalidDuration();\n        }\n        if (bytes(title).length == 0) {\n            revert EmptyTitle();\n        }\n\n        uint16 campaignId = campaignCount++;\n\n        campaigns[campaignId] = FundraisingStruct.Campaign({\n            owner: msg.sender,\n            title: title,\n            description: description,\n            totalRaised: FHE.asEuint64(0),\n            targetAmount: target,\n            deadline: block.timestamp + duration,\n            finalized: false,\n            cancelled: false,\n            tokenAddress: address(0)\n        });\n\n        FHE.allowThis(campaigns[campaignId].totalRaised);\n        FHE.allow(campaigns[campaignId].totalRaised, address(shareVault));\n        FHE.allow(campaigns[campaignId].totalRaised, msg.sender);\n\n        emit CampaignCreated(\n            campaignId,\n            msg.sender,\n            title,\n            target,\n            block.timestamp + duration\n        );\n        return campaignId;\n    }\n\n    /**\n     * @notice Make an encrypted contribution to a campaign\n     * @dev The contribution amount is encrypted and locked in the ShareVault. The actual amount\n     * remains private on-chain and can only be decrypted by authorized parties. Funds are locked\n     * until the campaign is finalized (either transferred to owner or refunded).\n     * @param campaignId The ID of the campaign to contribute to\n     * @param encryptedAmount The encrypted contribution amount (must be pre-encrypted by user)\n     * @param inputProof Zero-knowledge proof validating the encrypted input\n     * @custom:emits ContributionMade\n     */\n    function contribute(\n        uint16 campaignId,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof\n    ) external {\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        if (campaignId >= campaignCount) {\n            revert CampaignNotExist();\n        }\n\n        if (block.timestamp > campaign.deadline) {\n            revert CampaignEnded();\n        }\n\n        if (campaign.finalized) {\n            revert AlreadyFinalized();\n        }\n\n        if (campaign.cancelled) {\n            revert AlreadyCancelled();\n        }\n\n        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);\n\n        FHE.allowThis(amount);\n        FHE.allow(amount, address(shareVault));\n\n        // Lock funds in ShareVault\n        shareVault.lockFunds(msg.sender, campaignId, amount);\n\n        // Track contributor\n        if (!hasContributed[campaignId][msg.sender]) {\n            campaignContributors[campaignId].push(msg.sender);\n            hasContributed[campaignId][msg.sender] = true;\n        }\n\n        euint64 existingContribution = encryptedContributions[campaignId][\n            msg.sender\n        ];\n\n        euint64 newContribution;\n        if (FHE.isInitialized(existingContribution)) {\n            newContribution = FHE.add(existingContribution, amount);\n        } else {\n            newContribution = amount;\n        }\n\n        encryptedContributions[campaignId][msg.sender] = newContribution;\n\n        FHE.allowThis(newContribution);\n        FHE.allow(newContribution, address(shareVault));\n        FHE.allow(newContribution, msg.sender);\n\n        euint64 newTotal = FHE.add(campaign.totalRaised, amount);\n        campaign.totalRaised = newTotal;\n\n        FHE.allowThis(newTotal);\n        FHE.allow(newTotal, address(shareVault));\n        FHE.allow(newTotal, campaign.owner);\n\n        emit ContributionMade(campaignId, msg.sender);\n    }\n\n    /**\n     * @notice Finalizes a campaign after its deadline has passed\n     * @dev This function can only be called by the campaign owner after the deadline.\n     * The owner must first call requestTotalRaisedDecryption() to decrypt the total amount raised.\n     * If the target is reached, a new ERC20 token is deployed and funds are transferred to the owner.\n     * If the target is not reached, all locked funds are unlocked for contributor withdrawal.\n     * @param campaignId The ID of the campaign to finalize\n     * @param tokenName The name for the campaign token (required if target reached, can be empty otherwise)\n     * @param tokenSymbol The symbol for the campaign token (required if target reached, can be empty otherwise)\n     * @custom:emits CampaignFinalized\n     * @custom:emits CampaignFailed (if target not reached)\n     */\n    function finalizeCampaign(\n        uint16 campaignId,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external onlyCampaignOwner(campaignId) {\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        if (campaignId >= campaignCount) {\n            revert CampaignNotExist();\n        }\n\n        if (block.timestamp < campaign.deadline) {\n            revert CampaignStillActive();\n        }\n\n        if (campaign.finalized) {\n            revert AlreadyFinalized();\n        }\n\n        if (campaign.cancelled) {\n            revert AlreadyCancelled();\n        }\n\n        // Check if target was reached (need to decrypt total first)\n        // Owner must call requestTotalRaisedDecryption first, then call this function\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedTotalRaised[campaignId];\n        uint64 totalRaised = decryptedWithExp.data;\n\n        if (totalRaised == 0) {\n            revert TotalRaisedNotDecrypted();\n        }\n\n        campaign.finalized = true;\n\n        if (totalRaised >= campaign.targetAmount) {\n            // TARGET REACHED - Deploy token and transfer funds\n            if (bytes(tokenName).length == 0) {\n                revert TokenNameRequired();\n            }\n            if (bytes(tokenSymbol).length == 0) {\n                revert TokenSymbolRequired();\n            }\n\n            // Deploy campaign token\n            CampaignToken token = new CampaignToken(\n                tokenName,\n                tokenSymbol,\n                campaignId,\n                address(this) // Campaign contract is token owner\n            );\n            campaign.tokenAddress = address(token);\n\n            // Transfer all locked funds to owner\n            address[] memory contributors = campaignContributors[campaignId];\n            for (uint256 i = 0; i < contributors.length; i++) {\n                address contributor = contributors[i];\n                shareVault.transferLockedFunds(\n                    contributor,\n                    campaign.owner,\n                    campaignId\n                );\n            }\n\n            emit CampaignFinalized(campaignId, true);\n        } else {\n            // TARGET NOT REACHED - Unlock all funds (campaign failed)\n            address[] memory contributors = campaignContributors[campaignId];\n            for (uint256 i = 0; i < contributors.length; i++) {\n                shareVault.unlockFunds(contributors[i], campaignId);\n            }\n\n            emit CampaignFailed(campaignId);\n            emit CampaignFinalized(campaignId, false);\n        }\n    }\n\n    /**\n     * @notice Cancels an active campaign before its deadline\n     * @dev Only the campaign owner can cancel. This immediately unlocks all contributor funds\n     * and prevents any further contributions. The campaign cannot be finalized after cancellation.\n     * @param campaignId The ID of the campaign to cancel\n     * @custom:emits CampaignCancelled\n     */\n    function cancelCampaign(\n        uint16 campaignId\n    ) external onlyCampaignOwner(campaignId) {\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        if (campaignId >= campaignCount) {\n            revert CampaignNotExist();\n        }\n\n        if (campaign.finalized) {\n            revert AlreadyFinalized();\n        }\n\n        if (campaign.cancelled) {\n            revert AlreadyCancelled();\n        }\n\n        campaign.cancelled = true;\n\n        // Unlock all funds\n        address[] memory contributors = campaignContributors[campaignId];\n        for (uint256 i = 0; i < contributors.length; i++) {\n            shareVault.unlockFunds(contributors[i], campaignId);\n        }\n\n        emit CampaignCancelled(campaignId);\n    }\n\n    /**\n     * @notice Claims campaign tokens for a contributor after successful campaign finalization\n     * @dev Contributors must first decrypt their contribution amount by calling requestMyContributionDecryption().\n     * Tokens are distributed proportionally based on contribution amount relative to the target amount.\n     * Each contributor can only claim once.\n     * @param campaignId The ID of the successful campaign\n     * @custom:emits TokensClaimed\n     * @custom:emits TokensDistributed\n     */\n    function claimTokens(uint16 campaignId) external {\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        if (campaignId >= campaignCount) {\n            revert CampaignNotExist();\n        }\n\n        if (!campaign.finalized) {\n            revert CampaignNotFinalized();\n        }\n\n        if (campaign.tokenAddress == address(0)) {\n            revert NoTokensToClaim();\n        }\n\n        if (hasClaimed[campaignId][msg.sender]) {\n            revert AlreadyClaimed();\n        }\n\n        // User must have decrypted their contribution first\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedContributions[campaignId][\n                msg.sender\n            ];\n        uint64 contributionAmount = decryptedWithExp.data;\n\n        if (contributionAmount == 0) {\n            revert ContributionNotDecrypted();\n        }\n\n        // Calculate tokens based on proportion of target\n        // Formula: (userContribution / targetAmount) * 1_000_000_000 tokens\n        // To avoid precision loss: (userContribution * 1_000_000_000) / targetAmount\n\n        uint256 TOKEN_SUPPLY = 1_000_000_000 * 10 ** 18; // 1 billion tokens with 18 decimals\n        uint256 tokenAmount = (uint256(contributionAmount) * TOKEN_SUPPLY) /\n            uint256(campaign.targetAmount);\n\n        CampaignToken token = CampaignToken(campaign.tokenAddress);\n        token.mint(msg.sender, tokenAmount);\n\n        hasClaimed[campaignId][msg.sender] = true;\n\n        emit TokensClaimed(campaignId, msg.sender);\n        emit TokensDistributed(campaignId, msg.sender, tokenAmount);\n    }\n\n    /**\n     * @notice Retrieves public campaign information\n     * @dev Returns non-sensitive campaign data. Encrypted contribution amounts are not included.\n     * @param campaignId The ID of the campaign\n     * @return owner The address of the campaign creator\n     * @return title The campaign title\n     * @return description The campaign description\n     * @return targetAmount The funding target in wei\n     * @return deadline The campaign deadline timestamp\n     * @return finalized Whether the campaign has been finalized\n     * @return cancelled Whether the campaign has been cancelled\n     */\n    function getCampaign(\n        uint16 campaignId\n    )\n        external\n        view\n        returns (\n            address owner,\n            string memory title,\n            string memory description,\n            uint64 targetAmount,\n            uint256 deadline,\n            bool finalized,\n            bool cancelled\n        )\n    {\n        if (campaignId >= campaignCount) {\n            revert CampaignNotExist();\n        }\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        return (\n            campaign.owner,\n            campaign.title,\n            campaign.description,\n            campaign.targetAmount,\n            campaign.deadline,\n            campaign.finalized,\n            campaign.cancelled\n        );\n    }\n\n    /**\n     * @notice Requests decryption of the caller's contribution amount\n     * @dev Initiates an asynchronous decryption process. The result will be available after\n     * the decryption callback is executed. Use getMyContribution() to retrieve the decrypted value.\n     * @param campaignId The ID of the campaign\n     * @custom:emits DecryptionRequested (via callback system)\n     */\n    function requestMyContributionDecryption(uint16 campaignId) public {\n        euint64 userContribution = encryptedContributions[campaignId][\n            msg.sender\n        ];\n        if (!FHE.isInitialized(userContribution)) {\n            revert ContributionNotFound();\n        }\n\n        if (\n            decryptMyContributionStatus[campaignId][msg.sender] ==\n            CommonStruct.DecryptStatus.PROCESSING\n        ) {\n            revert DecryptAlreadyInProgress();\n        }\n\n        bytes32[] memory handles = new bytes32[](1);\n        handles[0] = FHE.toBytes32(\n            encryptedContributions[campaignId][msg.sender]\n        );\n\n        uint256 requestId = FHE.requestDecryption(\n            handles,\n            IDecryptionCallbacks.callbackDecryptMyContribution.selector\n        );\n\n        decryptMyContributionRequest[requestId] = FundraisingStruct\n            .DecryptUserContributionRequest({\n                userAddress: msg.sender,\n                campaignId: campaignId\n            });\n\n        decryptMyContributionStatus[campaignId][msg.sender] = CommonStruct\n            .DecryptStatus\n            .PROCESSING;\n    }\n\n    /**\n     * @notice Retrieves the caller's decrypted contribution amount\n     * @dev The contribution must be decrypted first by calling requestMyContributionDecryption().\n     * The decrypted value is cached with an expiration time.\n     * @param campaignId The ID of the campaign\n     * @return The decrypted contribution amount in wei\n     */\n    function getMyContribution(\n        uint16 campaignId\n    ) external view returns (uint64) {\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedContributions[campaignId][\n                msg.sender\n            ];\n\n        uint64 decryptedContribution = decryptedWithExp.data;\n        uint256 expTime = decryptedWithExp.exp;\n\n        if (decryptedContribution != 0) {\n            if (expTime < block.timestamp) {\n                revert CacheExpired();\n            }\n            return decryptedContribution;\n        }\n\n        if (\n            decryptMyContributionStatus[campaignId][msg.sender] ==\n            CommonStruct.DecryptStatus.PROCESSING\n        ) {\n            revert DataProcessing();\n        }\n\n        revert MyContributionNotDecrypted();\n    }\n\n    /**\n     * @notice Requests decryption of the total amount raised for a campaign\n     * @dev Only the campaign owner can request this. Required before finalizing a campaign.\n     * Initiates an asynchronous decryption process. Use getTotalRaised() to retrieve the result.\n     * @param campaignId The ID of the campaign\n     * @custom:emits DecryptionRequested (via callback system)\n     */\n    function requestTotalRaisedDecryption(\n        uint16 campaignId\n    ) public onlyCampaignOwner(campaignId) {\n        if (\n            decryptMyContributionStatus[campaignId][msg.sender] ==\n            CommonStruct.DecryptStatus.PROCESSING\n        ) {\n            revert DecryptAlreadyInProgress();\n        }\n\n        FundraisingStruct.Campaign storage campaign = campaigns[campaignId];\n\n        bytes32[] memory handles = new bytes32[](1);\n        handles[0] = FHE.toBytes32(campaign.totalRaised);\n\n        uint256 requestId = FHE.requestDecryption(\n            handles,\n            IDecryptionCallbacks.callbackDecryptTotalRaised.selector\n        );\n\n        decryptTotalRaisedRequest[requestId] = campaignId;\n        decryptTotalRaisedStatus[campaignId] = CommonStruct\n            .DecryptStatus\n            .PROCESSING;\n    }\n\n    /**\n     * @notice Retrieves the decrypted total amount raised for a campaign\n     * @dev Only the campaign owner can call this. The total must be decrypted first by calling\n     * requestTotalRaisedDecryption(). The decrypted value is cached with an expiration time.\n     * @param campaignId The ID of the campaign\n     * @return The decrypted total amount raised in wei\n     */\n    function getTotalRaised(\n        uint16 campaignId\n    ) external view onlyCampaignOwner(campaignId) returns (uint64) {\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedTotalRaised[campaignId];\n\n        uint64 decryptedTotalRaised = decryptedWithExp.data;\n        uint256 expTime = decryptedWithExp.exp;\n\n        if (decryptedTotalRaised != 0) {\n            if (expTime < block.timestamp) {\n                revert CacheExpired();\n            }\n            return decryptedTotalRaised;\n        }\n\n        if (\n            decryptTotalRaisedStatus[campaignId] ==\n            CommonStruct.DecryptStatus.PROCESSING\n        ) {\n            revert DataProcessing();\n        }\n\n        revert TotalRaisedNotDecrypted();\n    }\n\n    /**\n     * @notice Get the decryption status and cached total raised for a campaign\n     * @param campaignId The campaign ID\n     * @return status The decryption status (0=NONE, 1=PROCESSING, 2=DECRYPTED)\n     * @return totalRaised The decrypted total raised (0 if not decrypted)\n     * @return cacheExpiry The cache expiry timestamp\n     */\n    function getTotalRaisedStatus(\n        uint16 campaignId\n    )\n        external\n        view\n        onlyCampaignOwner(campaignId)\n        returns (\n            CommonStruct.DecryptStatus status,\n            uint64 totalRaised,\n            uint256 cacheExpiry\n        )\n    {\n        status = decryptTotalRaisedStatus[campaignId];\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedTotalRaised[campaignId];\n\n        totalRaised = decryptedWithExp.data;\n        cacheExpiry = decryptedWithExp.exp;\n\n        return (status, totalRaised, cacheExpiry);\n    }\n\n    /**\n     * @notice Get the decryption status and cached contribution for a user\n     * @param campaignId The campaign ID\n     * @param user The user address\n     * @return status The decryption status (0=NONE, 1=PROCESSING, 2=DECRYPTED)\n     * @return contribution The decrypted contribution (0 if not decrypted)\n     * @return cacheExpiry The cache expiry timestamp\n     */\n    function getContributionStatus(\n        uint16 campaignId,\n        address user\n    )\n        external\n        view\n        returns (\n            CommonStruct.DecryptStatus status,\n            uint64 contribution,\n            uint256 cacheExpiry\n        )\n    {\n        status = decryptMyContributionStatus[campaignId][user];\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedContributions[campaignId][user];\n\n        contribution = decryptedWithExp.data;\n        cacheExpiry = decryptedWithExp.exp;\n\n        return (status, contribution, cacheExpiry);\n    }\n\n    /**\n     * @notice Check if user has any contribution to a campaign\n     * @param campaignId The campaign ID\n     * @param user The user address\n     * @return hasContribution True if user has contributed\n     */\n    function hasContribution(\n        uint16 campaignId,\n        address user\n    ) external view returns (bool) {\n        return FHE.isInitialized(encryptedContributions[campaignId][user]);\n    }\n\n    /**\n     * @notice Retrieves the list of all contributors to a campaign\n     * @dev Returns addresses of all users who have made at least one contribution.\n     * Does not reveal contribution amounts.\n     * @param campaignId The ID of the campaign\n     * @return Array of contributor addresses\n     */\n    function getCampaignContributors(\n        uint16 campaignId\n    ) external view returns (address[] memory) {\n        return campaignContributors[campaignId];\n    }\n}\n"
    },
    "contracts/core/CampaignToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title CampaignToken\n * @notice ERC20 token distributed to contributors of successful fundraising campaigns\n * @dev This token is deployed automatically when a campaign reaches its funding target.\n * Contributors receive tokens proportional to their contribution relative to the campaign target.\n * The token has a fixed maximum supply of 1 billion tokens and can only be minted by the\n * ConfidentialFundraising contract (the owner).\n *\n * Token Distribution Formula:\n * userTokens = (userContribution / campaignTarget) * MAX_SUPPLY\n *\n * Key Features:\n * - ERC20 compliant with standard transfer functionality\n * - Fixed maximum supply of 1 billion tokens (with 18 decimals)\n * - Mintable only by the campaign contract owner\n * - Immutable campaign ID reference\n *\n * @custom:security-contact security@example.com\n */\ncontract CampaignToken is ERC20, Ownable {\n    uint256 public constant MAX_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens\n    uint16 public immutable campaignId;\n\n    error ExceedsMaxSupply();\n\n    /**\n     * @notice Constructs a new campaign token\n     * @dev Called by the ConfidentialFundraising contract when a campaign succeeds.\n     * The campaign contract becomes the owner with exclusive minting privileges.\n     * @param name The token name (chosen by campaign owner)\n     * @param symbol The token symbol (chosen by campaign owner)\n     * @param _campaignId The ID of the associated campaign\n     * @param initialOwner The address that will own this token (the campaign contract)\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint16 _campaignId,\n        address initialOwner\n    ) ERC20(name, symbol) Ownable(initialOwner) {\n        campaignId = _campaignId;\n    }\n    \n    /**\n     * @notice Mints tokens to a campaign contributor\n     * @dev Can only be called by the owner (ConfidentialFundraising contract).\n     * Called when a contributor claims their tokens after a successful campaign.\n     * The total supply across all mints cannot exceed MAX_SUPPLY.\n     * @param to The address of the contributor receiving tokens\n     * @param amount The amount of tokens to mint (with 18 decimals)\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        if (totalSupply() + amount > MAX_SUPPLY) {\n            revert ExceedsMaxSupply();\n        }\n        _mint(to, amount);\n    }\n}"
    },
    "contracts/core/EncryptedHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary EncryptedHelper {\n    function decodeUserContribution(\n        bytes memory cleartexts\n    ) internal pure returns (uint64 contributedAmount) {\n        assembly {\n            let dataPtr := add(cleartexts, 0x20)\n            contributedAmount := mload(dataPtr)\n        }\n\n        return (contributedAmount);\n    }\n\n    function decodeTotalRaised(\n        bytes memory cleartexts\n    ) internal pure returns (uint64 totalRaised) {\n        assembly {\n            let dataPtr := add(cleartexts, 0x20)\n            totalRaised := mload(dataPtr)\n        }\n\n        return (totalRaised);\n    }\n\n    function decodeAvailableBalance(\n        bytes memory cleartexts\n    ) internal pure returns (uint64 contributedAmount) {\n        assembly {\n            let dataPtr := add(cleartexts, 0x20)\n            contributedAmount := mload(dataPtr)\n        }\n\n        return (contributedAmount);\n    }\n\n    function decodeBool(\n        bytes memory cleartexts\n    ) internal pure returns (bool value) {\n        assembly {\n            let dataPtr := add(cleartexts, 0x20)\n            let rawValue := mload(dataPtr)\n            value := gt(rawValue, 0)\n        }\n        return (value);\n    }\n\n    /**\n     * @notice Decode uint64 from cleartext\n     */\n    function decodeUint64(\n        bytes memory cleartexts\n    ) internal pure returns (uint64 value) {\n        assembly {\n            let dataPtr := add(cleartexts, 0x20)\n            value := mload(dataPtr)\n        }\n        return (value);\n    }\n}\n"
    },
    "contracts/interface/IDecryptionCallbacks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IDecryptionCallbacks {\n\n    function callbackDecryptMyContribution(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external;\n\n    function callbackDecryptTotalRaised(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external;\n\n    function callbackDecryptAvailableBalance(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external;\n}\n"
    },
    "contracts/interface/IFundraisingErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IFundraisingErrors {\n    error DataProcessing();\n    error ContributionNotFound();\n    error CampaignNotExist();\n    error CampaignEnded();\n    error AlreadyCancelled();\n    error OnlyOwner();\n    error CampaignStillActive();\n    error AlreadyFinalized();\n    error CampaignNotFinalized();\n    error AlreadyClaimed();\n    error UnauthorizedAccess();\n    error TotalRaisedNotDecrypted();\n    error MyContributionNotDecrypted();\n    error CacheExpired();\n    error DecryptAlreadyInProgress();\n    error InvalidTarget();\n    error InvalidDuration();\n    error EmptyTitle();\n    error TokenNameRequired();\n    error TokenSymbolRequired();\n    error NoTokensToClaim();\n    error ContributionNotDecrypted();\n}\n"
    },
    "contracts/interface/IFundraisingEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IFundraisingEvents {\n    event CampaignCreated(\n        uint256 indexed campaignId,\n        address indexed owner,\n        string title,\n        uint256 targetAmount,\n        uint256 deadline\n    );\n    event ContributionMade(\n        uint256 indexed campaignId,\n        address indexed contributor\n    );\n    event CampaignFinalized(uint256 indexed campaignId, bool targetReached);\n    event CampaignCancelled(uint256 indexed campaignId);\n    event TokensClaimed(\n        uint256 indexed campaignId,\n        address indexed contributor\n    );\n    event TokensDistributed(\n        uint16 indexed campaignId,\n        address indexed contributor,\n        uint256 amount\n    );\n    event CampaignFailed(uint16 indexed campaignId);\n}\n"
    },
    "contracts/interface/impl/DecryptionCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport \"../IDecryptionCallbacks.sol\";\nimport \"../../core/EncryptedHelper.sol\";\nimport \"../../storage/FundraisingStorage.sol\";\nimport \"../../storage/ShareVaultStorage.sol\";\nimport \"../../struct/CommonStruct.sol\";\nimport \"../../struct/FundraisingStruct.sol\";\nimport \"../../struct/ShareVaultStruct.sol\";\n\ncontract DecryptionCallbacks is IDecryptionCallbacks, FundraisingStorage, ShareVaultStorage {\n\n    function callbackDecryptMyContribution(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external override {\n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n\n        uint64 contributedAmount = EncryptedHelper.decodeUserContribution(\n            cleartexts\n        );\n        FundraisingStruct.DecryptUserContributionRequest memory request = decryptMyContributionRequest[requestId];\n        decryptedContributions[request.campaignId][request.userAddress] = CommonStruct.Uint64ResultWithExp({\n            data: contributedAmount,\n            exp: block.timestamp + cacheTimeout\n        });\n\n        delete decryptMyContributionRequest[requestId];\n\n        decryptMyContributionStatus[request.campaignId][\n            request.userAddress\n        ] = CommonStruct.DecryptStatus.DECRYPTED;\n    }\n\n    function callbackDecryptTotalRaised(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external override {\n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n\n        uint16 campaignId = decryptTotalRaisedRequest[requestId];\n\n        uint64 totalRaised = EncryptedHelper.decodeTotalRaised(\n            cleartexts\n        );\n        decryptedTotalRaised[campaignId] = CommonStruct.Uint64ResultWithExp({\n            data: totalRaised,\n            exp: block.timestamp + cacheTimeout\n        });\n\n        delete decryptTotalRaisedRequest[requestId];\n        decryptTotalRaisedStatus[campaignId] = CommonStruct.DecryptStatus.DECRYPTED;\n    }\n\n    function callbackDecryptAvailableBalance(\n        uint256 requestId,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) external override {\n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n\n        uint64 availableAmount = EncryptedHelper.decodeAvailableBalance(cleartexts);\n\n        ShareVaultStruct.WithdrawalRequest memory request = withdrawalRequests[\n            requestId\n        ];\n\n        decryptedAvailableBalance[request.userAddress] = CommonStruct\n            .Uint64ResultWithExp({\n                data: availableAmount,\n                exp: block.timestamp + CACHE_TIMEOUT\n            });\n\n        delete withdrawalRequests[requestId];\n\n        availableBalanceStatus[request.userAddress] = CommonStruct\n            .DecryptStatus\n            .DECRYPTED;\n    }\n}"
    },
    "contracts/interface/IShareVaultErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IShareVaultErrors {\n    error OnlyCampaignContract();\n    error InsufficientBalance();\n    error InsufficientUnlockedBalance();\n    error WithdrawalFailed();\n    error MustDecryptFirst();\n    error DecryptionProcessing();\n    error DecryptionCacheExpired();\n    error DecryptAlreadyInProgress();\n    error OnlyOwner();\n    error CampaignContractAlreadySet();\n    error InvalidDepositAmount();\n    error DepositAmountTooLarge();\n    error NoBalance();\n    error InvalidWithdrawalAmount();\n    error InsufficientVaultBalance();\n    error InsufficientAvailableBalance();\n    error UserHasNoBalance();\n    error NoLockedAmount();\n}\n"
    },
    "contracts/interface/IShareVaultEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IShareVaultEvents {\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event FundsLocked(address indexed user, uint16 indexed campaignId);\n    event FundsUnlocked(address indexed user, uint16 indexed campaignId);\n    event FundsTransferred(\n        address indexed from,\n        address indexed to,\n        uint16 indexed campaignId\n    );\n    event WithdrawalDecryptionRequested(\n        address indexed user,\n        uint256 requestId\n    );\n    event AvailableBalanceDecrypted(address indexed user, uint64 amount);\n    event LockRequestInitiated(\n        address indexed user,\n        uint16 indexed campaignId,\n        uint256 requestId\n    );\n}\n"
    },
    "contracts/ShareVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport \"./interface/IDecryptionCallbacks.sol\";\nimport \"./struct/CommonStruct.sol\";\nimport \"./struct/ShareVaultStruct.sol\";\nimport \"./interface/IShareVaultErrors.sol\";\nimport \"./interface/IShareVaultEvents.sol\";\nimport \"./core/EncryptedHelper.sol\";\nimport \"./interface/impl/DecryptionCallback.sol\";\n\n/**\n * @title ShareVault\n * @notice Secure vault for managing encrypted user balances and campaign fund locks\n * @dev This contract acts as a decentralized escrow system for the ConfidentialFundraising platform.\n * It manages encrypted ETH balances, handles fund locking for active campaigns, and enables\n * privacy-preserving withdrawals through FHE-based balance verification.\n *\n * Key Features:\n * - Encrypted balance tracking for all users\n * - Campaign-specific fund locking mechanism\n * - Decryption-based withdrawal authorization\n * - Automatic balance permission management\n * - Support for multiple simultaneous campaign locks per user\n *\n * Security Model:\n * - Only the authorized campaign contract can lock/unlock/transfer funds\n * - Users must decrypt their available balance before withdrawal\n * - All encrypted operations use FHEVM for on-chain privacy\n *\n * @custom:security-contact security@example.com\n */\ncontract ShareVault is\n    SepoliaConfig,\n    IShareVaultEvents,\n    IShareVaultErrors,\n    ShareVaultStorage,\n    DecryptionCallbacks\n{\n    using FHE for euint64;\n    using FHE for ebool;\n\n    modifier onlyCampaignContract() {\n        if (msg.sender != campaignContract) {\n            revert OnlyCampaignContract();\n        }\n        _;\n    }\n\n    address public owner;\n\n    constructor() {\n        campaignContract = address(0);\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Sets the authorized campaign contract address\n     * @dev Can only be called once by the owner during initial setup. This address\n     * will have exclusive permission to lock, unlock, and transfer user funds.\n     * @param _campaignContract The address of the ConfidentialFundraising contract\n     */\n    function setCampaignContract(address _campaignContract) external {\n        if (msg.sender != owner) {\n            revert OnlyOwner();\n        }\n        if (campaignContract != address(0)) {\n            revert CampaignContractAlreadySet();\n        }\n        campaignContract = _campaignContract;\n    }\n\n    /**\n     * @notice Deposits ETH into the vault as an encrypted balance\n     * @dev The deposited amount is encrypted on-chain and added to the user's balance.\n     * Resets any cached decrypted balance values. Grants necessary FHE permissions\n     * to the user and campaign contract.\n     * @custom:emits Deposited\n     */\n    function deposit() external payable {\n        if (msg.value == 0) {\n            revert InvalidDepositAmount();\n        }\n        if (msg.value > type(uint64).max) {\n            revert DepositAmountTooLarge();\n        }\n\n        euint64 amount = FHE.asEuint64(uint64(msg.value));\n        euint64 currentBalance = encryptedBalances[msg.sender];\n\n        if (FHE.isInitialized(currentBalance)) {\n            encryptedBalances[msg.sender] = FHE.add(currentBalance, amount);\n        } else {\n            encryptedBalances[msg.sender] = amount;\n        }\n\n        // Grant permissions\n        FHE.allowThis(encryptedBalances[msg.sender]);\n        FHE.allow(encryptedBalances[msg.sender], msg.sender);\n\n        // Only allow campaignContract if it's set\n        if (campaignContract != address(0)) {\n            FHE.allow(encryptedBalances[msg.sender], campaignContract);\n        }\n\n        // Reset cache\n        decryptedAvailableBalance[msg.sender].data = 0;\n        decryptedAvailableBalance[msg.sender].exp = 0;\n        availableBalanceStatus[msg.sender] = CommonStruct.DecryptStatus.NONE;\n\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Requests decryption of the user's available balance\n     * @dev Calculates available balance as (total balance - total locked) and initiates\n     * an asynchronous decryption request. The result will be cached after the callback.\n     * Use getAvailableBalance() to retrieve the decrypted value.\n     * @custom:emits WithdrawalDecryptionRequested\n     */\n    function requestAvailableBalanceDecryption() external {\n        if (\n            availableBalanceStatus[msg.sender] ==\n            CommonStruct.DecryptStatus.PROCESSING\n        ) {\n            revert DecryptAlreadyInProgress();\n        }\n\n        euint64 balance = encryptedBalances[msg.sender];\n        if (!FHE.isInitialized(balance)) {\n            revert NoBalance();\n        }\n\n        // Calculate available balance: balance - locked\n        euint64 available;\n        euint64 locked = totalLocked[msg.sender];\n\n        if (FHE.isInitialized(locked)) {\n            available = FHE.sub(balance, locked);\n        } else {\n            available = balance;\n        }\n\n        // Allow the contract to read the available balance for decryption\n        FHE.allowThis(available);\n\n        // Request decryption\n        bytes32[] memory handles = new bytes32[](1);\n        handles[0] = FHE.toBytes32(available);\n\n        uint256 requestId = FHE.requestDecryption(\n            handles,\n            this.callbackDecryptAvailableBalance.selector\n        );\n\n        withdrawalRequests[requestId] = ShareVaultStruct.WithdrawalRequest({\n            userAddress: msg.sender\n        });\n\n        availableBalanceStatus[msg.sender] = CommonStruct\n            .DecryptStatus\n            .PROCESSING;\n\n        emit WithdrawalDecryptionRequested(msg.sender, requestId);\n    }\n\n    /**\n     * @notice Retrieves the user's decrypted available balance\n     * @dev The balance must be decrypted first by calling requestAvailableBalanceDecryption().\n     * Returns the cached decrypted value if not expired.\n     * @return The available balance in wei (total balance minus locked amounts)\n     */\n    function getAvailableBalance() external view returns (uint64) {\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedAvailableBalance[msg.sender];\n\n        uint64 available = decryptedWithExp.data;\n        uint256 expTime = decryptedWithExp.exp;\n\n        // Check if never decrypted\n        if (expTime == 0) {\n            if (\n                availableBalanceStatus[msg.sender] ==\n                CommonStruct.DecryptStatus.PROCESSING\n            ) {\n                revert DecryptionProcessing();\n            }\n            revert MustDecryptFirst();\n        }\n\n        // Check if expired\n        if (expTime < block.timestamp) {\n            revert DecryptionCacheExpired();\n        }\n\n        return available;\n    }\n\n    /**\n     * @notice Retrieves the decryption status and cached available balance\n     * @dev Useful for checking if decryption is in progress or if cache is expired\n     * @return status The current decryption status (NONE/PROCESSING/DECRYPTED)\n     * @return availableAmount The cached available balance (0 if not decrypted)\n     * @return cacheExpiry The timestamp when the cached value expires\n     */\n    function getAvailableBalanceStatus()\n        external\n        view\n        returns (\n            CommonStruct.DecryptStatus status,\n            uint64 availableAmount,\n            uint256 cacheExpiry\n        )\n    {\n        status = availableBalanceStatus[msg.sender];\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedAvailableBalance[msg.sender];\n\n        availableAmount = decryptedWithExp.data;\n        cacheExpiry = decryptedWithExp.exp;\n\n        return (status, availableAmount, cacheExpiry);\n    }\n\n    /**\n     * @notice Withdraws unlocked funds from the vault\n     * @dev Users must first decrypt their available balance. The decryption acts as\n     * authorization proof for the withdrawal. Resets the cached balance after withdrawal.\n     * @param amount The amount to withdraw in wei\n     * @custom:emits Withdrawn\n     */\n    function withdraw(uint64 amount) external {\n        if (amount == 0) {\n            revert InvalidWithdrawalAmount();\n        }\n        if (address(this).balance < amount) {\n            revert InsufficientVaultBalance();\n        }\n\n        // Check that user has decrypted their available balance\n        CommonStruct.Uint64ResultWithExp\n            memory decryptedWithExp = decryptedAvailableBalance[msg.sender];\n        uint64 available = decryptedWithExp.data;\n        uint256 expTime = decryptedWithExp.exp;\n\n        if (expTime == 0) {\n            if (\n                availableBalanceStatus[msg.sender] ==\n                CommonStruct.DecryptStatus.PROCESSING\n            ) {\n                revert DecryptionProcessing();\n            }\n            revert MustDecryptFirst();\n        }\n\n        if (expTime < block.timestamp) {\n            revert DecryptionCacheExpired();\n        }\n\n        // Check if user has enough available balance\n        if (available < amount) {\n            revert InsufficientAvailableBalance();\n        }\n\n        euint64 balance = encryptedBalances[msg.sender];\n        euint64 withdrawAmount = FHE.asEuint64(amount);\n\n        // Update balance\n        encryptedBalances[msg.sender] = FHE.sub(balance, withdrawAmount);\n\n        FHE.allowThis(encryptedBalances[msg.sender]);\n        FHE.allow(encryptedBalances[msg.sender], msg.sender);\n\n        // Only allow campaignContract if it's set\n        if (campaignContract != address(0)) {\n            FHE.allow(encryptedBalances[msg.sender], campaignContract);\n        }\n\n        // Reset cache\n        decryptedAvailableBalance[msg.sender].data = 0;\n        decryptedAvailableBalance[msg.sender].exp = 0;\n        availableBalanceStatus[msg.sender] = CommonStruct.DecryptStatus.NONE;\n\n        // Transfer ETH\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        if (!success) revert WithdrawalFailed();\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     * @notice Locks encrypted funds for a specific campaign\n     * @dev Called exclusively by the campaign contract when a user contributes.\n     * Operates entirely on encrypted values using FHE. If insufficient funds are available,\n     * safely locks 0 instead of reverting. Invalidates cached available balance.\n     * @param user The address of the contributor\n     * @param campaignId The ID of the campaign\n     * @param amount The encrypted amount to lock\n     * @custom:emits FundsLocked\n     */\n    function lockFunds(\n        address user,\n        uint16 campaignId,\n        euint64 amount\n    ) external onlyCampaignContract {\n        euint64 balance = encryptedBalances[user];\n\n        if (!FHE.isInitialized(balance)) {\n            revert UserHasNoBalance();\n        }\n\n        // Calculate available balance: balance - totalLocked\n        euint64 available;\n        euint64 locked = totalLocked[user];\n\n        if (FHE.isInitialized(locked)) {\n            available = FHE.sub(balance, locked);\n        } else {\n            available = balance;\n        }\n\n        FHE.allowThis(available);\n\n        ebool sufficientFunds = FHE.ge(available, amount);\n        FHE.allowThis(sufficientFunds);\n\n        // If insufficient funds, lock 0; otherwise lock the requested amount\n        euint64 safeAmount = FHE.select(\n            sufficientFunds,\n            amount,\n            FHE.asEuint64(0)\n        );\n\n        FHE.allowThis(safeAmount);\n\n        // Actually lock the funds\n        euint64 existingLock = lockedAmounts[user][campaignId];\n        if (FHE.isInitialized(existingLock)) {\n            lockedAmounts[user][campaignId] = FHE.add(existingLock, safeAmount);\n        } else {\n            lockedAmounts[user][campaignId] = safeAmount;\n        }\n\n        // Update total locked\n        if (FHE.isInitialized(locked)) {\n            totalLocked[user] = FHE.add(locked, safeAmount);\n        } else {\n            totalLocked[user] = safeAmount;\n        }\n\n        // Grant permissions\n        FHE.allowThis(lockedAmounts[user][campaignId]);\n        FHE.allow(lockedAmounts[user][campaignId], campaignContract);\n        FHE.allowThis(totalLocked[user]);\n\n        // Invalidate cached available balance since locked amount changed\n        delete decryptedAvailableBalance[user];\n        availableBalanceStatus[user] = CommonStruct.DecryptStatus.NONE;\n\n        emit FundsLocked(user, campaignId);\n    }\n\n    /**\n     * @notice Unlocks funds previously locked for a campaign\n     * @dev Called by the campaign contract when a campaign is cancelled or fails to reach\n     * its target. Returns funds to the user's available balance without transferring ETH.\n     * @param user The address of the contributor\n     * @param campaignId The ID of the campaign\n     * @custom:emits FundsUnlocked\n     */\n    function unlockFunds(\n        address user,\n        uint16 campaignId\n    ) external onlyCampaignContract {\n        euint64 lockedAmount = lockedAmounts[user][campaignId];\n        if (!FHE.isInitialized(lockedAmount)) {\n            revert NoLockedAmount();\n        }\n\n        // Decrease total locked\n        totalLocked[user] = FHE.sub(totalLocked[user], lockedAmount);\n\n        // Clear campaign lock\n        lockedAmounts[user][campaignId] = FHE.asEuint64(0);\n\n        // Invalidate cached available balance since locked amount changed\n        delete decryptedAvailableBalance[user];\n        availableBalanceStatus[user] = CommonStruct.DecryptStatus.NONE;\n\n        emit FundsUnlocked(user, campaignId);\n    }\n\n    /**\n     * @notice Transfers locked funds from contributor to campaign owner\n     * @dev Called by the campaign contract when a campaign succeeds. Moves encrypted funds\n     * from the contributor's balance to the campaign owner's balance within the vault.\n     * Does not transfer actual ETH - funds remain in the vault.\n     * @param user The address of the contributor\n     * @param campaignOwner The address of the campaign owner\n     * @param campaignId The ID of the successful campaign\n     * @return The encrypted locked amount that was transferred\n     * @custom:emits FundsTransferred\n     */\n    function transferLockedFunds(\n        address user,\n        address campaignOwner,\n        uint16 campaignId\n    ) external onlyCampaignContract returns (euint64) {\n        euint64 lockedAmount = lockedAmounts[user][campaignId];\n        if (!FHE.isInitialized(lockedAmount)) {\n            revert NoLockedAmount();\n        }\n\n        // Deduct from user's balance\n        encryptedBalances[user] = FHE.sub(\n            encryptedBalances[user],\n            lockedAmount\n        );\n\n        // Decrease total locked\n        totalLocked[user] = FHE.sub(totalLocked[user], lockedAmount);\n\n        // Add to owner's balance\n        euint64 ownerBalance = encryptedBalances[campaignOwner];\n        if (FHE.isInitialized(ownerBalance)) {\n            encryptedBalances[campaignOwner] = FHE.add(\n                ownerBalance,\n                lockedAmount\n            );\n        } else {\n            encryptedBalances[campaignOwner] = lockedAmount;\n        }\n\n        // Grant permissions\n        FHE.allowThis(encryptedBalances[campaignOwner]);\n        FHE.allow(encryptedBalances[campaignOwner], campaignOwner);\n\n        // Clear campaign lock\n        euint64 returnAmount = lockedAmount;\n        lockedAmounts[user][campaignId] = FHE.asEuint64(0);\n\n        // Invalidate cached available balance\n        delete decryptedAvailableBalance[user];\n        availableBalanceStatus[user] = CommonStruct.DecryptStatus.NONE;\n\n        emit FundsTransferred(user, campaignOwner, campaignId);\n\n        return returnAmount;\n    }\n\n    /**\n     * @notice Retrieves the user's encrypted total balance\n     * @dev Returns the raw encrypted value. Only the user and authorized contracts\n     * can decrypt this value.\n     * @return The encrypted balance as euint64\n     */\n    function getEncryptedBalance() external view returns (euint64) {\n        return encryptedBalances[msg.sender];\n    }\n\n    /**\n     * @notice Retrieves the user's encrypted locked amount for a specific campaign\n     * @dev Returns the raw encrypted value representing funds locked for this campaign.\n     * @param campaignId The ID of the campaign\n     * @return The encrypted locked amount as euint64\n     */\n    function getLockedAmount(\n        uint16 campaignId\n    ) external view returns (euint64) {\n        return lockedAmounts[msg.sender][campaignId];\n    }\n\n    /**\n     * @notice Retrieves the user's total encrypted locked amount across all campaigns\n     * @dev Returns the sum of all campaign locks for this user.\n     * @return The total encrypted locked amount as euint64\n     */\n    function getTotalLocked() external view returns (euint64) {\n        return totalLocked[msg.sender];\n    }\n}\n"
    },
    "contracts/storage/FundraisingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"../struct/FundraisingStruct.sol\";\nimport \"../struct/CommonStruct.sol\";\n\nabstract contract FundraisingStorage {\n    uint256 cacheTimeout = 600; // 10 mins cache\n\n    mapping(uint16 => FundraisingStruct.Campaign) public campaigns;\n\n    mapping(uint16 => mapping(address => bool)) public hasClaimed;\n\n    mapping(uint16 => mapping(address => euint64)) internal encryptedContributions;\n    mapping(uint16 => mapping(address => CommonStruct.Uint64ResultWithExp)) internal decryptedContributions;\n\n    mapping(uint16 => CommonStruct.Uint64ResultWithExp) internal decryptedTotalRaised;\n    mapping(uint256 => uint16) internal decryptTotalRaisedRequest;\n    mapping(uint16 => CommonStruct.DecryptStatus) internal decryptTotalRaisedStatus;\n\n    mapping(uint256 => FundraisingStruct.DecryptUserContributionRequest) internal decryptMyContributionRequest;\n    mapping(uint16 => mapping(address => CommonStruct.DecryptStatus)) internal decryptMyContributionStatus;\n\n    uint16 public campaignCount;\n\n    // Mapping to track contributors per campaign\n    mapping(uint16 => address[]) internal campaignContributors;\n    mapping(uint16 => mapping(address => bool)) internal hasContributed;\n    \n    // Token claim tracking\n    mapping(uint16 => mapping(address => bool)) public hasClaimedTokens;\n}"
    },
    "contracts/storage/ShareVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"../struct/ShareVaultStruct.sol\";\nimport \"../struct/CommonStruct.sol\";\n\nabstract contract ShareVaultStorage {\n    // User balances (encrypted)\n    mapping(address => euint64) internal encryptedBalances;\n\n    // Locked amounts per user per campaign (encrypted)\n    mapping(address => mapping(uint16 => euint64)) internal lockedAmounts;\n\n    // Total locked per user (encrypted)\n    mapping(address => euint64) internal totalLocked;\n\n    // Decryption status and cached available balance\n    mapping(address => CommonStruct.DecryptStatus)\n        internal availableBalanceStatus;\n    mapping(address => CommonStruct.Uint64ResultWithExp)\n        internal decryptedAvailableBalance;\n    mapping(uint256 => ShareVaultStruct.WithdrawalRequest)\n        internal withdrawalRequests;\n\n    // Campaign contract address (authorized to lock/unlock)\n    address public campaignContract;\n\n    // Cache timeout (10 minutes)\n    uint256 public constant CACHE_TIMEOUT = 600;\n}"
    },
    "contracts/struct/CommonStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\n\nlibrary CommonStruct {\n    enum DecryptStatus {\n        NONE,\n        PROCESSING,\n        DECRYPTED\n    }\n\n    struct Uint64ResultWithExp {\n        uint64 data;\n        uint256 exp;\n    }\n}\n"
    },
    "contracts/struct/FundraisingStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\n\nlibrary FundraisingStruct {\n    struct Campaign {\n        address owner;\n        string title;\n        string description;\n        euint64 totalRaised;\n        uint64 targetAmount;\n        uint256 deadline;\n        bool finalized;\n        bool cancelled;\n        address tokenAddress;\n    }\n\n    struct DecryptUserContributionRequest {\n        address userAddress;\n        uint16 campaignId;\n    }\n}\n"
    },
    "contracts/struct/ShareVaultStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@fhevm/solidity/lib/FHE.sol\";\n\nlibrary ShareVaultStruct {\n    struct WithdrawalRequest {\n        address userAddress;\n    }\n    \n    struct LockRequest {\n        address user;\n        uint16 campaignId;\n        euint64 amount;\n    }\n}\n"
    },
    "encrypted-types/EncryptedTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ntype ebool is bytes32;\n\ntype euint8 is bytes32;\ntype euint16 is bytes32;\ntype euint24 is bytes32;\ntype euint32 is bytes32;\ntype euint40 is bytes32;\ntype euint48 is bytes32;\ntype euint56 is bytes32;\ntype euint64 is bytes32;\ntype euint72 is bytes32;\ntype euint80 is bytes32;\ntype euint88 is bytes32;\ntype euint96 is bytes32;\ntype euint104 is bytes32;\ntype euint112 is bytes32;\ntype euint120 is bytes32;\ntype euint128 is bytes32;\ntype euint136 is bytes32;\ntype euint144 is bytes32;\ntype euint152 is bytes32;\ntype euint160 is bytes32;\ntype euint168 is bytes32;\ntype euint176 is bytes32;\ntype euint184 is bytes32;\ntype euint192 is bytes32;\ntype euint200 is bytes32;\ntype euint208 is bytes32;\ntype euint216 is bytes32;\ntype euint224 is bytes32;\ntype euint232 is bytes32;\ntype euint240 is bytes32;\ntype euint248 is bytes32;\ntype euint256 is bytes32;\n\ntype eint8 is bytes32;\ntype eint16 is bytes32;\ntype eint24 is bytes32;\ntype eint32 is bytes32;\ntype eint40 is bytes32;\ntype eint48 is bytes32;\ntype eint56 is bytes32;\ntype eint64 is bytes32;\ntype eint72 is bytes32;\ntype eint80 is bytes32;\ntype eint88 is bytes32;\ntype eint96 is bytes32;\ntype eint104 is bytes32;\ntype eint112 is bytes32;\ntype eint120 is bytes32;\ntype eint128 is bytes32;\ntype eint136 is bytes32;\ntype eint144 is bytes32;\ntype eint152 is bytes32;\ntype eint160 is bytes32;\ntype eint168 is bytes32;\ntype eint176 is bytes32;\ntype eint184 is bytes32;\ntype eint192 is bytes32;\ntype eint200 is bytes32;\ntype eint208 is bytes32;\ntype eint216 is bytes32;\ntype eint224 is bytes32;\ntype eint232 is bytes32;\ntype eint240 is bytes32;\ntype eint248 is bytes32;\ntype eint256 is bytes32;\n\ntype eaddress is bytes32;\n\ntype ebytes1 is bytes32;\ntype ebytes2 is bytes32;\ntype ebytes3 is bytes32;\ntype ebytes4 is bytes32;\ntype ebytes5 is bytes32;\ntype ebytes6 is bytes32;\ntype ebytes7 is bytes32;\ntype ebytes8 is bytes32;\ntype ebytes9 is bytes32;\ntype ebytes10 is bytes32;\ntype ebytes11 is bytes32;\ntype ebytes12 is bytes32;\ntype ebytes13 is bytes32;\ntype ebytes14 is bytes32;\ntype ebytes15 is bytes32;\ntype ebytes16 is bytes32;\ntype ebytes17 is bytes32;\ntype ebytes18 is bytes32;\ntype ebytes19 is bytes32;\ntype ebytes20 is bytes32;\ntype ebytes21 is bytes32;\ntype ebytes22 is bytes32;\ntype ebytes23 is bytes32;\ntype ebytes24 is bytes32;\ntype ebytes25 is bytes32;\ntype ebytes26 is bytes32;\ntype ebytes27 is bytes32;\ntype ebytes28 is bytes32;\ntype ebytes29 is bytes32;\ntype ebytes30 is bytes32;\ntype ebytes31 is bytes32;\ntype ebytes32 is bytes32;\n\ntype externalEbool is bytes32;\n\ntype externalEuint8 is bytes32;\ntype externalEuint16 is bytes32;\ntype externalEuint24 is bytes32;\ntype externalEuint32 is bytes32;\ntype externalEuint40 is bytes32;\ntype externalEuint48 is bytes32;\ntype externalEuint56 is bytes32;\ntype externalEuint64 is bytes32;\ntype externalEuint72 is bytes32;\ntype externalEuint80 is bytes32;\ntype externalEuint88 is bytes32;\ntype externalEuint96 is bytes32;\ntype externalEuint104 is bytes32;\ntype externalEuint112 is bytes32;\ntype externalEuint120 is bytes32;\ntype externalEuint128 is bytes32;\ntype externalEuint136 is bytes32;\ntype externalEuint144 is bytes32;\ntype externalEuint152 is bytes32;\ntype externalEuint160 is bytes32;\ntype externalEuint168 is bytes32;\ntype externalEuint176 is bytes32;\ntype externalEuint184 is bytes32;\ntype externalEuint192 is bytes32;\ntype externalEuint200 is bytes32;\ntype externalEuint208 is bytes32;\ntype externalEuint216 is bytes32;\ntype externalEuint224 is bytes32;\ntype externalEuint232 is bytes32;\ntype externalEuint240 is bytes32;\ntype externalEuint248 is bytes32;\ntype externalEuint256 is bytes32;\n\ntype externalEint8 is bytes32;\ntype externalEint16 is bytes32;\ntype externalEint24 is bytes32;\ntype externalEint32 is bytes32;\ntype externalEint40 is bytes32;\ntype externalEint48 is bytes32;\ntype externalEint56 is bytes32;\ntype externalEint64 is bytes32;\ntype externalEint72 is bytes32;\ntype externalEint80 is bytes32;\ntype externalEint88 is bytes32;\ntype externalEint96 is bytes32;\ntype externalEint104 is bytes32;\ntype externalEint112 is bytes32;\ntype externalEint120 is bytes32;\ntype externalEint128 is bytes32;\ntype externalEint136 is bytes32;\ntype externalEint144 is bytes32;\ntype externalEint152 is bytes32;\ntype externalEint160 is bytes32;\ntype externalEint168 is bytes32;\ntype externalEint176 is bytes32;\ntype externalEint184 is bytes32;\ntype externalEint192 is bytes32;\ntype externalEint200 is bytes32;\ntype externalEint208 is bytes32;\ntype externalEint216 is bytes32;\ntype externalEint224 is bytes32;\ntype externalEint232 is bytes32;\ntype externalEint240 is bytes32;\ntype externalEint248 is bytes32;\ntype externalEint256 is bytes32;\n\ntype externalEaddress is bytes32;\n\ntype externalEbytes1 is bytes32;\ntype externalEbytes2 is bytes32;\ntype externalEbytes3 is bytes32;\ntype externalEbytes4 is bytes32;\ntype externalEbytes5 is bytes32;\ntype externalEbytes6 is bytes32;\ntype externalEbytes7 is bytes32;\ntype externalEbytes8 is bytes32;\ntype externalEbytes9 is bytes32;\ntype externalEbytes10 is bytes32;\ntype externalEbytes11 is bytes32;\ntype externalEbytes12 is bytes32;\ntype externalEbytes13 is bytes32;\ntype externalEbytes14 is bytes32;\ntype externalEbytes15 is bytes32;\ntype externalEbytes16 is bytes32;\ntype externalEbytes17 is bytes32;\ntype externalEbytes18 is bytes32;\ntype externalEbytes19 is bytes32;\ntype externalEbytes20 is bytes32;\ntype externalEbytes21 is bytes32;\ntype externalEbytes22 is bytes32;\ntype externalEbytes23 is bytes32;\ntype externalEbytes24 is bytes32;\ntype externalEbytes25 is bytes32;\ntype externalEbytes26 is bytes32;\ntype externalEbytes27 is bytes32;\ntype externalEbytes28 is bytes32;\ntype externalEbytes29 is bytes32;\ntype externalEbytes30 is bytes32;\ntype externalEbytes31 is bytes32;\ntype externalEbytes32 is bytes32;\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}