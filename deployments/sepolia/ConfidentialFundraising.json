{
  "address": "0x40f55006d0cF9664D99ce1f699A32dbD26F97d0B",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "CampaignCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "title",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "targetAmount",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "CampaignCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "targetReached",
          "type": "bool"
        }
      ],
      "name": "CampaignFinalized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        }
      ],
      "name": "ContributionMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "contributor",
          "type": "address"
        }
      ],
      "name": "TokensClaimed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "campaignCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "campaigns",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "title",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "description",
          "type": "string"
        },
        {
          "internalType": "euint64",
          "name": "totalRaised",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "targetAmount",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "finalized",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "cancelled",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "cancelCampaign",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "claimTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        },
        {
          "internalType": "einput",
          "name": "encAmount",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "contribute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "title",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "description",
          "type": "string"
        },
        {
          "internalType": "uint64",
          "name": "target",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "createCampaign",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "finalizeCampaign",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "getCampaign",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "title",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "description",
          "type": "string"
        },
        {
          "internalType": "uint64",
          "name": "targetAmount",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "finalized",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "cancelled",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "getEncryptedTotal",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "campaignId",
          "type": "uint256"
        }
      ],
      "name": "getMyContribution",
      "outputs": [
        {
          "internalType": "euint64",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasClaimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x49c0d7b546179a7095bc7f25a710f18f1b99d8620af2ff1668c858f8cfc4f144",
  "receipt": {
    "to": null,
    "from": "0x1b66CEA12f45794e8454F3a1A30dDBF03f377519",
    "contractAddress": "0x40f55006d0cF9664D99ce1f699A32dbD26F97d0B",
    "transactionIndex": 40,
    "gasUsed": "1524718",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa5270e6eac0d594ed3e91e27fcba987cff0c64fa26b176d5c2532a596634d4f1",
    "transactionHash": "0x49c0d7b546179a7095bc7f25a710f18f1b99d8620af2ff1668c858f8cfc4f144",
    "logs": [],
    "blockNumber": 9345790,
    "cumulativeGasUsed": "12855119",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "d45ed4758a24c900babb9ce5c3cef5ce",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"CampaignCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"targetAmount\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"CampaignCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"targetReached\",\"type\":\"bool\"}],\"name\":\"CampaignFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"ContributionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"campaignCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"campaigns\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"euint64\",\"name\":\"totalRaised\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"targetAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"cancelCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"internalType\":\"einput\",\"name\":\"encAmount\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"target\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"createCampaign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"finalizeCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"getCampaign\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"targetAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"getEncryptedTotal\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"}],\"name\":\"getMyContribution\",\"outputs\":[{\"internalType\":\"euint64\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Uses FHEVM to keep individual contributions private while tracking totals\",\"kind\":\"dev\",\"methods\":{\"cancelCampaign(uint256)\":{\"params\":{\"campaignId\":\"ID of the campaign\"}},\"claimTokens(uint256)\":{\"params\":{\"campaignId\":\"ID of the campaign\"}},\"contribute(uint256,bytes32,bytes)\":{\"params\":{\"campaignId\":\"ID of the campaign\",\"encAmount\":\"Encrypted contribution amount\",\"inputProof\":\"Zero-knowledge proof for the encrypted input\"}},\"createCampaign(string,string,uint64,uint256)\":{\"params\":{\"description\":\"Campaign description\",\"duration\":\"Duration in seconds\",\"target\":\"Target amount in wei\",\"title\":\"Campaign title\"}},\"finalizeCampaign(uint256)\":{\"details\":\"In production, use Gateway async decryption to check if target reached\",\"params\":{\"campaignId\":\"ID of the campaign\"}},\"getCampaign(uint256)\":{\"params\":{\"campaignId\":\"ID of the campaign\"}},\"getEncryptedTotal(uint256)\":{\"params\":{\"campaignId\":\"ID of the campaign\"}},\"getMyContribution(uint256)\":{\"params\":{\"campaignId\":\"ID of the campaign\"}}},\"title\":\"ConfidentialFundraising\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"cancelCampaign(uint256)\":{\"notice\":\"Cancel a campaign (only owner, before finalization)\"},\"claimTokens(uint256)\":{\"notice\":\"Claim tokens after successful campaign\"},\"contribute(uint256,bytes32,bytes)\":{\"notice\":\"Contribute encrypted amount to a campaign\"},\"createCampaign(string,string,uint64,uint256)\":{\"notice\":\"Create a new fundraising campaign\"},\"finalizeCampaign(uint256)\":{\"notice\":\"Finalize a campaign after deadline\"},\"getCampaign(uint256)\":{\"notice\":\"Get campaign details\"},\"getEncryptedTotal(uint256)\":{\"notice\":\"Get encrypted total raised (only owner can decrypt via re-encryption)\"},\"getMyContribution(uint256)\":{\"notice\":\"Get encrypted contribution for the caller\"}},\"notice\":\"A private fundraising platform where contribution amounts remain encrypted\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ConfidentialFundraising.sol\":\"ConfidentialFundraising\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ConfidentialFundraising.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport \\\"fhevm/lib/TFHE.sol\\\";\\nimport \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\n\\n/**\\n * @title ConfidentialFundraising\\n * @notice A private fundraising platform where contribution amounts remain encrypted\\n * @dev Uses FHEVM to keep individual contributions private while tracking totals\\n */\\ncontract ConfidentialFundraising is SepoliaZamaFHEVMConfig {\\n    struct Campaign {\\n        address owner;\\n        string title;\\n        string description;\\n        euint64 totalRaised;        // Encrypted total amount raised\\n        uint64 targetAmount;        // Public goal (in wei)\\n        uint256 deadline;           // Campaign end time\\n        bool finalized;             // Whether campaign has been finalized\\n        bool cancelled;             // Whether campaign was cancelled\\n    }\\n    \\n    // Campaign ID => Campaign data\\n    mapping(uint256 => Campaign) public campaigns;\\n    \\n    // Campaign ID => Contributor address => Encrypted contribution amount\\n    mapping(uint256 => mapping(address => euint64)) private contributions;\\n    \\n    // Campaign ID => Contributor address => Has claimed tokens\\n    mapping(uint256 => mapping(address => bool)) public hasClaimed;\\n    \\n    // Total number of campaigns created\\n    uint256 public campaignCount;\\n    \\n    // Events\\n    event CampaignCreated(\\n        uint256 indexed campaignId,\\n        address indexed owner,\\n        string title,\\n        uint64 targetAmount,\\n        uint256 deadline\\n    );\\n    \\n    event ContributionMade(\\n        uint256 indexed campaignId,\\n        address indexed contributor\\n    );\\n    \\n    event CampaignFinalized(\\n        uint256 indexed campaignId,\\n        bool targetReached\\n    );\\n    \\n    event CampaignCancelled(uint256 indexed campaignId);\\n    \\n    event TokensClaimed(\\n        uint256 indexed campaignId,\\n        address indexed contributor\\n    );\\n    \\n    /**\\n     * @notice Create a new fundraising campaign\\n     * @param title Campaign title\\n     * @param description Campaign description\\n     * @param target Target amount in wei\\n     * @param duration Duration in seconds\\n     */\\n    function createCampaign(\\n        string calldata title,\\n        string calldata description,\\n        uint64 target,\\n        uint256 duration\\n    ) external returns (uint256) {\\n        require(target > 0, \\\"Target must be greater than 0\\\");\\n        require(duration > 0, \\\"Duration must be greater than 0\\\");\\n        require(bytes(title).length > 0, \\\"Title cannot be empty\\\");\\n        \\n        uint256 campaignId = campaignCount++;\\n        \\n        campaigns[campaignId] = Campaign({\\n            owner: msg.sender,\\n            title: title,\\n            description: description,\\n            totalRaised: TFHE.asEuint64(0),\\n            targetAmount: target,\\n            deadline: block.timestamp + duration,\\n            finalized: false,\\n            cancelled: false\\n        });\\n        \\n        // Grant contract permission to access totalRaised\\n        TFHE.allowThis(campaigns[campaignId].totalRaised);\\n        // Grant owner permission to see total\\n        TFHE.allow(campaigns[campaignId].totalRaised, msg.sender);\\n        \\n        emit CampaignCreated(campaignId, msg.sender, title, target, block.timestamp + duration);\\n        \\n        return campaignId;\\n    }\\n    \\n    /**\\n     * @notice Contribute encrypted amount to a campaign\\n     * @param campaignId ID of the campaign\\n     * @param encAmount Encrypted contribution amount\\n     * @param inputProof Zero-knowledge proof for the encrypted input\\n     */\\n    function contribute(\\n        uint256 campaignId,\\n        einput encAmount,\\n        bytes calldata inputProof\\n    ) external {\\n        Campaign storage campaign = campaigns[campaignId];\\n        \\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        require(block.timestamp < campaign.deadline, \\\"Campaign has ended\\\");\\n        require(!campaign.finalized, \\\"Campaign already finalized\\\");\\n        require(!campaign.cancelled, \\\"Campaign was cancelled\\\");\\n        \\n        // Convert encrypted input with proof verification\\n        euint64 amount = TFHE.asEuint64(encAmount, inputProof);\\n        \\n        // Get existing contribution or zero if first time\\n        euint64 existingContribution = contributions[campaignId][msg.sender];\\n        \\n        // Add to user's contribution\\n        euint64 newContribution;\\n        if (TFHE.isInitialized(existingContribution)) {\\n            newContribution = TFHE.add(existingContribution, amount);\\n        } else {\\n            newContribution = amount;\\n        }\\n        \\n        contributions[campaignId][msg.sender] = newContribution;\\n        \\n        // Grant permissions\\n        TFHE.allowThis(newContribution);\\n        TFHE.allow(newContribution, msg.sender);\\n        \\n        // Update total raised homomorphically\\n        euint64 newTotal = TFHE.add(campaign.totalRaised, amount);\\n        campaign.totalRaised = newTotal;\\n        \\n        // Grant permissions for total\\n        TFHE.allowThis(newTotal);\\n        TFHE.allow(newTotal, campaign.owner);\\n        \\n        emit ContributionMade(campaignId, msg.sender);\\n    }\\n    \\n    /**\\n     * @notice Finalize a campaign after deadline\\n     * @param campaignId ID of the campaign\\n     * @dev In production, use Gateway async decryption to check if target reached\\n     */\\n    function finalizeCampaign(uint256 campaignId) external {\\n        Campaign storage campaign = campaigns[campaignId];\\n        \\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        require(msg.sender == campaign.owner, \\\"Only owner can finalize\\\");\\n        require(block.timestamp >= campaign.deadline, \\\"Campaign still active\\\");\\n        require(!campaign.finalized, \\\"Already finalized\\\");\\n        require(!campaign.cancelled, \\\"Campaign was cancelled\\\");\\n        \\n        campaign.finalized = true;\\n        \\n        // Note: In production, you would use async decryption via Gateway\\n        // to check if target was reached. For this demo, we just finalize.\\n        // The owner can view the encrypted total using re-encryption on the frontend.\\n        emit CampaignFinalized(campaignId, true);\\n    }\\n    \\n    /**\\n     * @notice Cancel a campaign (only owner, before finalization)\\n     * @param campaignId ID of the campaign\\n     */\\n    function cancelCampaign(uint256 campaignId) external {\\n        Campaign storage campaign = campaigns[campaignId];\\n        \\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        require(msg.sender == campaign.owner, \\\"Only owner can cancel\\\");\\n        require(!campaign.finalized, \\\"Already finalized\\\");\\n        require(!campaign.cancelled, \\\"Already cancelled\\\");\\n        \\n        campaign.cancelled = true;\\n        \\n        emit CampaignCancelled(campaignId);\\n    }\\n    \\n    /**\\n     * @notice Claim tokens after successful campaign\\n     * @param campaignId ID of the campaign\\n     */\\n    function claimTokens(uint256 campaignId) external {\\n        Campaign storage campaign = campaigns[campaignId];\\n        \\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        require(campaign.finalized, \\\"Campaign not finalized\\\");\\n        require(!campaign.cancelled, \\\"Campaign was cancelled\\\");\\n        require(!hasClaimed[campaignId][msg.sender], \\\"Already claimed\\\");\\n        \\n        euint64 userContribution = contributions[campaignId][msg.sender];\\n        require(TFHE.isInitialized(userContribution), \\\"No contribution found\\\");\\n        \\n        // Verify user has permission to access their contribution\\n        require(TFHE.isSenderAllowed(userContribution), \\\"Unauthorized access\\\");\\n        \\n        // Mark as claimed\\n        hasClaimed[campaignId][msg.sender] = true;\\n        \\n        // In a real implementation, this would calculate proportional token allocation\\n        // and transfer tokens. For this demo, we just emit an event.\\n        \\n        emit TokensClaimed(campaignId, msg.sender);\\n    }\\n    \\n    /**\\n     * @notice Get campaign details\\n     * @param campaignId ID of the campaign\\n     */\\n    function getCampaign(uint256 campaignId) external view returns (\\n        address owner,\\n        string memory title,\\n        string memory description,\\n        uint64 targetAmount,\\n        uint256 deadline,\\n        bool finalized,\\n        bool cancelled\\n    ) {\\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        Campaign storage campaign = campaigns[campaignId];\\n        \\n        return (\\n            campaign.owner,\\n            campaign.title,\\n            campaign.description,\\n            campaign.targetAmount,\\n            campaign.deadline,\\n            campaign.finalized,\\n            campaign.cancelled\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get encrypted total raised (only owner can decrypt via re-encryption)\\n     * @param campaignId ID of the campaign\\n     */\\n    function getEncryptedTotal(uint256 campaignId) external view returns (euint64) {\\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        return campaigns[campaignId].totalRaised;\\n    }\\n    \\n    /**\\n     * @notice Get encrypted contribution for the caller\\n     * @param campaignId ID of the campaign\\n     */\\n    function getMyContribution(uint256 campaignId) external view returns (euint64) {\\n        require(campaignId < campaignCount, \\\"Campaign does not exist\\\");\\n        return contributions[campaignId][msg.sender];\\n    }\\n}\",\"keccak256\":\"0x9254d00ae6bcfbcc6bae99c97fea33ca98f1adb527c96c3c9ab8d99b56856aa6\",\"license\":\"MIT\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x89d4968cd956a8931f1a8a177b3bef1c6cf88a03665083db74430add50b88f21\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f80fd5b5061018a6100ae604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b80517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b6118e0806101975f395ff3fe608060405234801561000f575f80fd5b50600436106100a6575f3560e01c80637274e30d1161006e5780637274e30d1461013b578063799d405514610152578063873f6f9e14610165578063a3361290146101a2578063aa39e6c8146101b5578063cf33f48d146101c8575f80fd5b8063141961bc146100aa57806345598b4a146100da57806346e04a2f146100ef5780635598f8cc146101025780636b5ca27d14610128575b5f80fd5b6100bd6100b8366004611342565b6101db565b6040516100d198979695949392919061139c565b60405180910390f35b6100ed6100e8366004611342565b610343565b005b6100ed6100fd366004611342565b6104a1565b610115610110366004611342565b61069c565b6040516100d1979695949392919061140e565b6100ed610136366004611342565b610845565b61014460035481565b6040519081526020016100d1565b6101446101603660046114bb565b6109d6565b610192610173366004611546565b600260209081525f928352604080842090915290825290205460ff1681565b60405190151581526020016100d1565b6101446101b0366004611342565b610cf0565b6100ed6101c336600461157f565b610d27565b6101446101d6366004611342565b610f2e565b5f60208190529081526040902080546001820180546001600160a01b039092169291610206906115ce565b80601f0160208091040260200160405190810160405280929190818152602001828054610232906115ce565b801561027d5780601f106102545761010080835404028352916020019161027d565b820191905f5260205f20905b81548152906001019060200180831161026057829003601f168201915b505050505090806002018054610292906115ce565b80601f01602080910402602001604051908101604052809291908181526020018280546102be906115ce565b80156103095780601f106102e057610100808354040283529160200191610309565b820191905f5260205f20905b8154815290600101906020018083116102ec57829003601f168201915b505050506003830154600484015460058501546006909501549394919367ffffffffffffffff909116925060ff8082169161010090041688565b5f818152602081905260409020600354821061037a5760405162461bcd60e51b815260040161037190611606565b60405180910390fd5b80546001600160a01b031633146103cb5760405162461bcd60e51b815260206004820152601560248201527413db9b1e481bdddb995c8818d85b8818d85b98d95b605a1b6044820152606401610371565b600681015460ff16156104145760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e48199a5b985b1a5e9959607a1b6044820152606401610371565b6006810154610100900460ff16156104625760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e4818d85b98d95b1b1959607a1b6044820152606401610371565b60068101805461ff00191661010017905560405182907f403b6718db13878ac16c27decb08f09d3a10f116c7c25af575ff5bfbc11ae9e6905f90a25050565b5f81815260208190526040902060035482106104cf5760405162461bcd60e51b815260040161037190611606565b600681015460ff1661051c5760405162461bcd60e51b815260206004820152601660248201527510d85b5c185a59db881b9bdd08199a5b985b1a5e995960521b6044820152606401610371565b6006810154610100900460ff16156105465760405162461bcd60e51b81526004016103719061163d565b5f82815260026020908152604080832033845290915290205460ff16156105a15760405162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e4818db185a5b5959608a1b6044820152606401610371565b5f828152600160209081526040808320338452909152902054806105ff5760405162461bcd60e51b8152602060048201526015602482015274139bc818dbdb9d1c9a589d5d1a5bdb88199bdd5b99605a1b6044820152606401610371565b61060881610f6d565b61064a5760405162461bcd60e51b8152602060048201526013602482015272556e617574686f72697a65642061636365737360681b6044820152606401610371565b5f838152600260209081526040808320338085529252808320805460ff1916600117905551909185917f83017964d41e2eb3369a74f93ce7024dc09d85d2bfa35ca86268234733b965909190a3505050565b5f6060805f805f8060035488106106c55760405162461bcd60e51b815260040161037190611606565b5f88815260208190526040902080546004820154600583015460068401546001850180546001600160a01b03909516949093600287019367ffffffffffffffff90911692909160ff80831692610100900416908690610723906115ce565b80601f016020809104026020016040519081016040528092919081815260200182805461074f906115ce565b801561079a5780601f106107715761010080835404028352916020019161079a565b820191905f5260205f20905b81548152906001019060200180831161077d57829003601f168201915b505050505095508480546107ad906115ce565b80601f01602080910402602001604051908101604052809291908181526020018280546107d9906115ce565b80156108245780601f106107fb57610100808354040283529160200191610824565b820191905f5260205f20905b81548152906001019060200180831161080757829003601f168201915b50505050509450975097509750975097509750975050919395979092949650565b5f81815260208190526040902060035482106108735760405162461bcd60e51b815260040161037190611606565b80546001600160a01b031633146108cc5760405162461bcd60e51b815260206004820152601760248201527f4f6e6c79206f776e65722063616e2066696e616c697a650000000000000000006044820152606401610371565b80600501544210156109185760405162461bcd60e51b815260206004820152601560248201527443616d706169676e207374696c6c2061637469766560581b6044820152606401610371565b600681015460ff16156109615760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e48199a5b985b1a5e9959607a1b6044820152606401610371565b6006810154610100900460ff161561098b5760405162461bcd60e51b81526004016103719061163d565b60068101805460ff1916600190811790915560405190815282907f153ed4c9c4475018e4899faf78c3171cc7869a9c53a2d247de2ff74377eba7889060200160405180910390a25050565b5f808367ffffffffffffffff1611610a305760405162461bcd60e51b815260206004820152601d60248201527f546172676574206d7573742062652067726561746572207468616e20300000006044820152606401610371565b5f8211610a7f5760405162461bcd60e51b815260206004820152601f60248201527f4475726174696f6e206d7573742062652067726561746572207468616e2030006044820152606401610371565b85610ac45760405162461bcd60e51b81526020600482015260156024820152745469746c652063616e6e6f7420626520656d70747960581b6044820152606401610371565b600380545f9182610ad483611681565b919050559050604051806101000160405280336001600160a01b0316815260200189898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250604080516020601f8a01819004810282018101909252888152918101919089908990819084018382808284375f920182905250938552505060209092019150610b7590610f7e565b815267ffffffffffffffff86166020820152604001610b948542611699565b81525f60208083018290526040928301829052848252818152919020825181546001600160a01b0319166001600160a01b03909116178155908201516001820190610bdf908261170c565b5060408201516002820190610bf4908261170c565b506060820151600382810191909155608083015160048301805467ffffffffffffffff191667ffffffffffffffff90921691909117905560a0830151600583015560c08301516006909201805460e09094015161ffff1990941692151561ff00191692909217610100931515939093029290921790555f8281526020819052604090200154610c8290610f8a565b5f81815260208190526040902060030154610c9d9033610f97565b33817fcbabe2e3fd62ba83db1d5f355dc6a430cbb0ff23be3baf8d717b1a51b13cda1c8a8a88610ccd8942611699565b604051610cdd94939291906117cc565b60405180910390a3979650505050505050565b5f6003548210610d125760405162461bcd60e51b815260040161037190611606565b505f9081526020819052604090206003015490565b5f8481526020819052604090206003548510610d555760405162461bcd60e51b815260040161037190611606565b80600501544210610d9d5760405162461bcd60e51b815260206004820152601260248201527110d85b5c185a59db881a185cc8195b99195960721b6044820152606401610371565b600681015460ff1615610df25760405162461bcd60e51b815260206004820152601a60248201527f43616d706169676e20616c72656164792066696e616c697a65640000000000006044820152606401610371565b6006810154610100900460ff1615610e1c5760405162461bcd60e51b81526004016103719061163d565b5f610e5c8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610fa592505050565b5f8781526001602090815260408083203384529091528120549192508115610e8f57610e888284610fb9565b9050610e92565b50815b5f8881526001602090815260408083203384529091529020819055610eb681610f8a565b610ec08133610f97565b5f610ecf856003015485610fb9565b600386018190559050610ee181610f8a565b8454610ef79082906001600160a01b0316610f97565b60405133908a907f307c1c8dcf9e5e0b374f6c475ff7c473dd02a9248096afa14405976e4ea1eb6a905f90a3505050505050505050565b5f6003548210610f505760405162461bcd60e51b815260040161037190611606565b505f90815260016020908152604080832033845290915290205490565b5f610f788233610fe7565b92915050565b5f610f78826005611073565b610f948130611106565b50565b610fa18282611106565b5050565b5f610fb28383600561117c565b9392505050565b5f82610fcb57610fc85f610f7e565b92505b81610fdc57610fd95f610f7e565b91505b610fb283835f61128d565b5f805f8051602061188b8339815191528054604051632fd514cd60e11b8152600481018790526001600160a01b038681166024830152929350911690635faa299a90604401602060405180830381865afa158015611047573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061106b9190611814565b949350505050565b5f805f8051602061188b8339815191526001810154604051631ce2e8d760e31b8152600481018790526001600160f81b031960f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af11580156110e2573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061106b9190611833565b5f5f8051602061188b8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015611161575f80fd5b505af1158015611173573d5f803e3d5ffd5b50505050505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516302e817ff60e41b81525f915f8051602061188b833981519152916001600160a01b0390911690632e817ff0906111e69088903390899060f88a901b9060040161184a565b6020604051808303815f875af1158015611202573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112269190611833565b81546040516346ce4e4960e11b8152600481018390523360248201529193506001600160a01b031690638d9c9c92906044015f604051808303815f87803b15801561126f575f80fd5b505af1158015611281573d5f803e3d5ffd5b50505050509392505050565b5f8082156112a05750600160f81b6112a3565b505f5b5f5f8051602061188b833981519152600181015460405163f953e42760e01b815260048101899052602481018890526001600160f81b0319851660448201529192506001600160a01b03169063f953e427906064016020604051808303815f875af1158015611314573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113389190611833565b9695505050505050565b5f60208284031215611352575f80fd5b5035919050565b5f81518084525f5b8181101561137d57602081850181015186830182015201611361565b505f602082860101526020601f19601f83011685010191505092915050565b6001600160a01b0389168152610100602082018190525f906113c08382018b611359565b905082810360408401526113d4818a611359565b6060840198909852505067ffffffffffffffff94909416608085015260a0840192909252151560c0830152151560e0909101529392505050565b6001600160a01b038816815260e0602082018190525f9061143190830189611359565b82810360408401526114438189611359565b67ffffffffffffffff9790971660608401525050608081019390935290151560a0830152151560c0909101529392505050565b5f8083601f840112611486575f80fd5b50813567ffffffffffffffff81111561149d575f80fd5b6020830191508360208285010111156114b4575f80fd5b9250929050565b5f805f805f80608087890312156114d0575f80fd5b863567ffffffffffffffff808211156114e7575f80fd5b6114f38a838b01611476565b9098509650602089013591508082111561150b575f80fd5b6115178a838b01611476565b9096509450604089013591508082168214611530575f80fd5b5080925050606087013590509295509295509295565b5f8060408385031215611557575f80fd5b8235915060208301356001600160a01b0381168114611574575f80fd5b809150509250929050565b5f805f8060608587031215611592575f80fd5b8435935060208501359250604085013567ffffffffffffffff8111156115b6575f80fd5b6115c287828801611476565b95989497509550505050565b600181811c908216806115e257607f821691505b60208210810361160057634e487b7160e01b5f52602260045260245ffd5b50919050565b60208082526017908201527f43616d706169676e20646f6573206e6f74206578697374000000000000000000604082015260600190565b60208082526016908201527510d85b5c185a59db881dd85cc818d85b98d95b1b195960521b604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b5f600182016116925761169261166d565b5060010190565b80820180821115610f7857610f7861166d565b634e487b7160e01b5f52604160045260245ffd5b601f82111561170757805f5260205f20601f840160051c810160208510156116e55750805b601f840160051c820191505b81811015611704575f81556001016116f1565b50505b505050565b815167ffffffffffffffff811115611726576117266116ac565b61173a8161173484546115ce565b846116c0565b602080601f83116001811461176d575f84156117565750858301515b5f19600386901b1c1916600185901b1785556117c4565b5f85815260208120601f198616915b8281101561179b5788860151825594840194600190910190840161177c565b50858210156117b857878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b60608152836060820152838560808301375f608085830101525f6080601f19601f870116830101905067ffffffffffffffff8416602083015282604083015295945050505050565b5f60208284031215611824575f80fd5b81518015158114610fb2575f80fd5b5f60208284031215611843575f80fd5b5051919050565b8481526001600160a01b03841660208201526080604082018190525f9061187390830185611359565b905060ff60f81b831660608301529594505050505056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a264697066735822122042ac9e7f80bcfe6297a8465eb174b89ff1f308b601b0bdbba4622b14187b9c6a64736f6c63430008180033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b50600436106100a6575f3560e01c80637274e30d1161006e5780637274e30d1461013b578063799d405514610152578063873f6f9e14610165578063a3361290146101a2578063aa39e6c8146101b5578063cf33f48d146101c8575f80fd5b8063141961bc146100aa57806345598b4a146100da57806346e04a2f146100ef5780635598f8cc146101025780636b5ca27d14610128575b5f80fd5b6100bd6100b8366004611342565b6101db565b6040516100d198979695949392919061139c565b60405180910390f35b6100ed6100e8366004611342565b610343565b005b6100ed6100fd366004611342565b6104a1565b610115610110366004611342565b61069c565b6040516100d1979695949392919061140e565b6100ed610136366004611342565b610845565b61014460035481565b6040519081526020016100d1565b6101446101603660046114bb565b6109d6565b610192610173366004611546565b600260209081525f928352604080842090915290825290205460ff1681565b60405190151581526020016100d1565b6101446101b0366004611342565b610cf0565b6100ed6101c336600461157f565b610d27565b6101446101d6366004611342565b610f2e565b5f60208190529081526040902080546001820180546001600160a01b039092169291610206906115ce565b80601f0160208091040260200160405190810160405280929190818152602001828054610232906115ce565b801561027d5780601f106102545761010080835404028352916020019161027d565b820191905f5260205f20905b81548152906001019060200180831161026057829003601f168201915b505050505090806002018054610292906115ce565b80601f01602080910402602001604051908101604052809291908181526020018280546102be906115ce565b80156103095780601f106102e057610100808354040283529160200191610309565b820191905f5260205f20905b8154815290600101906020018083116102ec57829003601f168201915b505050506003830154600484015460058501546006909501549394919367ffffffffffffffff909116925060ff8082169161010090041688565b5f818152602081905260409020600354821061037a5760405162461bcd60e51b815260040161037190611606565b60405180910390fd5b80546001600160a01b031633146103cb5760405162461bcd60e51b815260206004820152601560248201527413db9b1e481bdddb995c8818d85b8818d85b98d95b605a1b6044820152606401610371565b600681015460ff16156104145760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e48199a5b985b1a5e9959607a1b6044820152606401610371565b6006810154610100900460ff16156104625760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e4818d85b98d95b1b1959607a1b6044820152606401610371565b60068101805461ff00191661010017905560405182907f403b6718db13878ac16c27decb08f09d3a10f116c7c25af575ff5bfbc11ae9e6905f90a25050565b5f81815260208190526040902060035482106104cf5760405162461bcd60e51b815260040161037190611606565b600681015460ff1661051c5760405162461bcd60e51b815260206004820152601660248201527510d85b5c185a59db881b9bdd08199a5b985b1a5e995960521b6044820152606401610371565b6006810154610100900460ff16156105465760405162461bcd60e51b81526004016103719061163d565b5f82815260026020908152604080832033845290915290205460ff16156105a15760405162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e4818db185a5b5959608a1b6044820152606401610371565b5f828152600160209081526040808320338452909152902054806105ff5760405162461bcd60e51b8152602060048201526015602482015274139bc818dbdb9d1c9a589d5d1a5bdb88199bdd5b99605a1b6044820152606401610371565b61060881610f6d565b61064a5760405162461bcd60e51b8152602060048201526013602482015272556e617574686f72697a65642061636365737360681b6044820152606401610371565b5f838152600260209081526040808320338085529252808320805460ff1916600117905551909185917f83017964d41e2eb3369a74f93ce7024dc09d85d2bfa35ca86268234733b965909190a3505050565b5f6060805f805f8060035488106106c55760405162461bcd60e51b815260040161037190611606565b5f88815260208190526040902080546004820154600583015460068401546001850180546001600160a01b03909516949093600287019367ffffffffffffffff90911692909160ff80831692610100900416908690610723906115ce565b80601f016020809104026020016040519081016040528092919081815260200182805461074f906115ce565b801561079a5780601f106107715761010080835404028352916020019161079a565b820191905f5260205f20905b81548152906001019060200180831161077d57829003601f168201915b505050505095508480546107ad906115ce565b80601f01602080910402602001604051908101604052809291908181526020018280546107d9906115ce565b80156108245780601f106107fb57610100808354040283529160200191610824565b820191905f5260205f20905b81548152906001019060200180831161080757829003601f168201915b50505050509450975097509750975097509750975050919395979092949650565b5f81815260208190526040902060035482106108735760405162461bcd60e51b815260040161037190611606565b80546001600160a01b031633146108cc5760405162461bcd60e51b815260206004820152601760248201527f4f6e6c79206f776e65722063616e2066696e616c697a650000000000000000006044820152606401610371565b80600501544210156109185760405162461bcd60e51b815260206004820152601560248201527443616d706169676e207374696c6c2061637469766560581b6044820152606401610371565b600681015460ff16156109615760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e48199a5b985b1a5e9959607a1b6044820152606401610371565b6006810154610100900460ff161561098b5760405162461bcd60e51b81526004016103719061163d565b60068101805460ff1916600190811790915560405190815282907f153ed4c9c4475018e4899faf78c3171cc7869a9c53a2d247de2ff74377eba7889060200160405180910390a25050565b5f808367ffffffffffffffff1611610a305760405162461bcd60e51b815260206004820152601d60248201527f546172676574206d7573742062652067726561746572207468616e20300000006044820152606401610371565b5f8211610a7f5760405162461bcd60e51b815260206004820152601f60248201527f4475726174696f6e206d7573742062652067726561746572207468616e2030006044820152606401610371565b85610ac45760405162461bcd60e51b81526020600482015260156024820152745469746c652063616e6e6f7420626520656d70747960581b6044820152606401610371565b600380545f9182610ad483611681565b919050559050604051806101000160405280336001600160a01b0316815260200189898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250604080516020601f8a01819004810282018101909252888152918101919089908990819084018382808284375f920182905250938552505060209092019150610b7590610f7e565b815267ffffffffffffffff86166020820152604001610b948542611699565b81525f60208083018290526040928301829052848252818152919020825181546001600160a01b0319166001600160a01b03909116178155908201516001820190610bdf908261170c565b5060408201516002820190610bf4908261170c565b506060820151600382810191909155608083015160048301805467ffffffffffffffff191667ffffffffffffffff90921691909117905560a0830151600583015560c08301516006909201805460e09094015161ffff1990941692151561ff00191692909217610100931515939093029290921790555f8281526020819052604090200154610c8290610f8a565b5f81815260208190526040902060030154610c9d9033610f97565b33817fcbabe2e3fd62ba83db1d5f355dc6a430cbb0ff23be3baf8d717b1a51b13cda1c8a8a88610ccd8942611699565b604051610cdd94939291906117cc565b60405180910390a3979650505050505050565b5f6003548210610d125760405162461bcd60e51b815260040161037190611606565b505f9081526020819052604090206003015490565b5f8481526020819052604090206003548510610d555760405162461bcd60e51b815260040161037190611606565b80600501544210610d9d5760405162461bcd60e51b815260206004820152601260248201527110d85b5c185a59db881a185cc8195b99195960721b6044820152606401610371565b600681015460ff1615610df25760405162461bcd60e51b815260206004820152601a60248201527f43616d706169676e20616c72656164792066696e616c697a65640000000000006044820152606401610371565b6006810154610100900460ff1615610e1c5760405162461bcd60e51b81526004016103719061163d565b5f610e5c8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250610fa592505050565b5f8781526001602090815260408083203384529091528120549192508115610e8f57610e888284610fb9565b9050610e92565b50815b5f8881526001602090815260408083203384529091529020819055610eb681610f8a565b610ec08133610f97565b5f610ecf856003015485610fb9565b600386018190559050610ee181610f8a565b8454610ef79082906001600160a01b0316610f97565b60405133908a907f307c1c8dcf9e5e0b374f6c475ff7c473dd02a9248096afa14405976e4ea1eb6a905f90a3505050505050505050565b5f6003548210610f505760405162461bcd60e51b815260040161037190611606565b505f90815260016020908152604080832033845290915290205490565b5f610f788233610fe7565b92915050565b5f610f78826005611073565b610f948130611106565b50565b610fa18282611106565b5050565b5f610fb28383600561117c565b9392505050565b5f82610fcb57610fc85f610f7e565b92505b81610fdc57610fd95f610f7e565b91505b610fb283835f61128d565b5f805f8051602061188b8339815191528054604051632fd514cd60e11b8152600481018790526001600160a01b038681166024830152929350911690635faa299a90604401602060405180830381865afa158015611047573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061106b9190611814565b949350505050565b5f805f8051602061188b8339815191526001810154604051631ce2e8d760e31b8152600481018790526001600160f81b031960f887901b1660248201529192506001600160a01b03169063e71746b8906044016020604051808303815f875af11580156110e2573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061106b9190611833565b5f5f8051602061188b8339815191528054604051631974142760e21b8152600481018690526001600160a01b0385811660248301529293509116906365d0509c906044015f604051808303815f87803b158015611161575f80fd5b505af1158015611173573d5f803e3d5ffd5b50505050505050565b7fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601546040516302e817ff60e41b81525f915f8051602061188b833981519152916001600160a01b0390911690632e817ff0906111e69088903390899060f88a901b9060040161184a565b6020604051808303815f875af1158015611202573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906112269190611833565b81546040516346ce4e4960e11b8152600481018390523360248201529193506001600160a01b031690638d9c9c92906044015f604051808303815f87803b15801561126f575f80fd5b505af1158015611281573d5f803e3d5ffd5b50505050509392505050565b5f8082156112a05750600160f81b6112a3565b505f5b5f5f8051602061188b833981519152600181015460405163f953e42760e01b815260048101899052602481018890526001600160f81b0319851660448201529192506001600160a01b03169063f953e427906064016020604051808303815f875af1158015611314573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906113389190611833565b9695505050505050565b5f60208284031215611352575f80fd5b5035919050565b5f81518084525f5b8181101561137d57602081850181015186830182015201611361565b505f602082860101526020601f19601f83011685010191505092915050565b6001600160a01b0389168152610100602082018190525f906113c08382018b611359565b905082810360408401526113d4818a611359565b6060840198909852505067ffffffffffffffff94909416608085015260a0840192909252151560c0830152151560e0909101529392505050565b6001600160a01b038816815260e0602082018190525f9061143190830189611359565b82810360408401526114438189611359565b67ffffffffffffffff9790971660608401525050608081019390935290151560a0830152151560c0909101529392505050565b5f8083601f840112611486575f80fd5b50813567ffffffffffffffff81111561149d575f80fd5b6020830191508360208285010111156114b4575f80fd5b9250929050565b5f805f805f80608087890312156114d0575f80fd5b863567ffffffffffffffff808211156114e7575f80fd5b6114f38a838b01611476565b9098509650602089013591508082111561150b575f80fd5b6115178a838b01611476565b9096509450604089013591508082168214611530575f80fd5b5080925050606087013590509295509295509295565b5f8060408385031215611557575f80fd5b8235915060208301356001600160a01b0381168114611574575f80fd5b809150509250929050565b5f805f8060608587031215611592575f80fd5b8435935060208501359250604085013567ffffffffffffffff8111156115b6575f80fd5b6115c287828801611476565b95989497509550505050565b600181811c908216806115e257607f821691505b60208210810361160057634e487b7160e01b5f52602260045260245ffd5b50919050565b60208082526017908201527f43616d706169676e20646f6573206e6f74206578697374000000000000000000604082015260600190565b60208082526016908201527510d85b5c185a59db881dd85cc818d85b98d95b1b195960521b604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b5f600182016116925761169261166d565b5060010190565b80820180821115610f7857610f7861166d565b634e487b7160e01b5f52604160045260245ffd5b601f82111561170757805f5260205f20601f840160051c810160208510156116e55750805b601f840160051c820191505b81811015611704575f81556001016116f1565b50505b505050565b815167ffffffffffffffff811115611726576117266116ac565b61173a8161173484546115ce565b846116c0565b602080601f83116001811461176d575f84156117565750858301515b5f19600386901b1c1916600185901b1785556117c4565b5f85815260208120601f198616915b8281101561179b5788860151825594840194600190910190840161177c565b50858210156117b857878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b60608152836060820152838560808301375f608085830101525f6080601f19601f870116830101905067ffffffffffffffff8416602083015282604083015295945050505050565b5f60208284031215611824575f80fd5b81518015158114610fb2575f80fd5b5f60208284031215611843575f80fd5b5051919050565b8481526001600160a01b03841660208201526080604082018190525f9061187390830185611359565b905060ff60f81b831660608301529594505050505056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600a264697066735822122042ac9e7f80bcfe6297a8465eb174b89ff1f308b601b0bdbba4622b14187b9c6a64736f6c63430008180033",
  "devdoc": {
    "details": "Uses FHEVM to keep individual contributions private while tracking totals",
    "kind": "dev",
    "methods": {
      "cancelCampaign(uint256)": {
        "params": {
          "campaignId": "ID of the campaign"
        }
      },
      "claimTokens(uint256)": {
        "params": {
          "campaignId": "ID of the campaign"
        }
      },
      "contribute(uint256,bytes32,bytes)": {
        "params": {
          "campaignId": "ID of the campaign",
          "encAmount": "Encrypted contribution amount",
          "inputProof": "Zero-knowledge proof for the encrypted input"
        }
      },
      "createCampaign(string,string,uint64,uint256)": {
        "params": {
          "description": "Campaign description",
          "duration": "Duration in seconds",
          "target": "Target amount in wei",
          "title": "Campaign title"
        }
      },
      "finalizeCampaign(uint256)": {
        "details": "In production, use Gateway async decryption to check if target reached",
        "params": {
          "campaignId": "ID of the campaign"
        }
      },
      "getCampaign(uint256)": {
        "params": {
          "campaignId": "ID of the campaign"
        }
      },
      "getEncryptedTotal(uint256)": {
        "params": {
          "campaignId": "ID of the campaign"
        }
      },
      "getMyContribution(uint256)": {
        "params": {
          "campaignId": "ID of the campaign"
        }
      }
    },
    "title": "ConfidentialFundraising",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "cancelCampaign(uint256)": {
        "notice": "Cancel a campaign (only owner, before finalization)"
      },
      "claimTokens(uint256)": {
        "notice": "Claim tokens after successful campaign"
      },
      "contribute(uint256,bytes32,bytes)": {
        "notice": "Contribute encrypted amount to a campaign"
      },
      "createCampaign(string,string,uint64,uint256)": {
        "notice": "Create a new fundraising campaign"
      },
      "finalizeCampaign(uint256)": {
        "notice": "Finalize a campaign after deadline"
      },
      "getCampaign(uint256)": {
        "notice": "Get campaign details"
      },
      "getEncryptedTotal(uint256)": {
        "notice": "Get encrypted total raised (only owner can decrypt via re-encryption)"
      },
      "getMyContribution(uint256)": {
        "notice": "Get encrypted contribution for the caller"
      }
    },
    "notice": "A private fundraising platform where contribution amounts remain encrypted",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 29,
        "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
        "label": "campaigns",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Campaign)24_storage)"
      },
      {
        "astId": 36,
        "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
        "label": "contributions",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_userDefinedValueType(euint64)2452))"
      },
      {
        "astId": 42,
        "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
        "label": "hasClaimed",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 44,
        "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
        "label": "campaignCount",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_userDefinedValueType(euint64)2452)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => euint64)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(euint64)2452"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_userDefinedValueType(euint64)2452))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => euint64))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_userDefinedValueType(euint64)2452)"
      },
      "t_mapping(t_uint256,t_struct(Campaign)24_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ConfidentialFundraising.Campaign)",
        "numberOfBytes": "32",
        "value": "t_struct(Campaign)24_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Campaign)24_storage": {
        "encoding": "inplace",
        "label": "struct ConfidentialFundraising.Campaign",
        "members": [
          {
            "astId": 8,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 10,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "title",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 12,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "description",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 15,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "totalRaised",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint64)2452"
          },
          {
            "astId": 17,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "targetAmount",
            "offset": 0,
            "slot": "4",
            "type": "t_uint64"
          },
          {
            "astId": 19,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "deadline",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 21,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "finalized",
            "offset": 0,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 23,
            "contract": "contracts/ConfidentialFundraising.sol:ConfidentialFundraising",
            "label": "cancelled",
            "offset": 1,
            "slot": "6",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_userDefinedValueType(euint64)2452": {
        "encoding": "inplace",
        "label": "euint64",
        "numberOfBytes": "32"
      }
    }
  }
}